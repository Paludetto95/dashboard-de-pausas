<!DOCTYPE html>
<html lang="pt-BR" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Análise de Pausas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://unpkg.com/tabulator-tables@5.5.2/dist/css/tabulator_bootstrap5.min.css" rel="stylesheet">
    <script type="text/javascript" src="https://unpkg.com/tabulator-tables@5.5.2/dist/js/tabulator.min.js"></script>
    <style>
        /* --- 1. Paleta de Cores e Tema --- */
        :root {
            --bg-main: #1C1C24;
            --bg-container: #252532;
            --text-main: #F0F0F0;
            --text-secondary: #A0A0A0;
            --highlight-primary: #3A7FFF;
            --highlight-secondary-yellow: #FBC02D;
            --highlight-secondary-purple: #E040FB;
            --status-success: #00C853;
            --status-danger: #D50000;
            /* Glassmorphism tokens */
            --glass-bg: rgba(17, 24, 39, 0.28);
            --glass-border: rgba(255, 255, 255, 0.14);
            --glass-shadow: 0 10px 28px rgba(0, 0, 0, 0.30);
            --glass-blur: blur(14px) saturate(120%);
            --glass-radius: 14px;
            /* Background image overlay */
            --dashboard-bg-image: url('800x600_como-a-analise-de-dados-pode-enriquecer-a-apresentacao-de-resultados-393-9915.png');
            --dashboard-bg-opacity: 1; /* opacidade total do overlay composto */
            --dashboard-bg-darkness: 0.68; /* ~20% mais claro que 0.85 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(180deg, #0f1117 0%, #1C1C24 40%, #121318 100%);
            color: var(--text-secondary);
        }

        /* Overlay do background com 80% de opacidade */
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            /* Camadas: preto por cima da imagem para escurecer fortemente */
            background-image: linear-gradient(rgba(0,0,0,var(--dashboard-bg-darkness)), rgba(0,0,0,var(--dashboard-bg-darkness))), var(--dashboard-bg-image);
            background-position: center;
            background-size: cover;
            background-repeat: no-repeat;
            opacity: var(--dashboard-bg-opacity);
            pointer-events: none;
            z-index: -1; /* garante que fique atrás do conteúdo */
        }

        /* --- 2. Tipografia e Hierarquia --- */
        h1 {
            font-size: 2.25rem;
            line-height: 2.5rem;
            font-weight: 800;
            color: var(--text-main);
        }

        h2 {
            font-size: 1.25rem;
            line-height: 1.75rem;
            font-weight: 600;
            color: var(--text-main);
        }

        .kpi-value {
            font-size: 2.25rem;
            line-height: 2.5rem;
            font-weight: 700;
            color: var(--text-main);
        }
        
        .support-text {
            font-size: 0.875rem;
            line-height: 1.25rem;
            font-weight: 400;
            color: var(--text-secondary);
        }

        /* --- 3. Componentes e Layout --- */
        .card {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            padding: 1.25rem;
            border-radius: var(--glass-radius);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sidebar .card {
             background: var(--glass-bg);
             backdrop-filter: var(--glass-blur);
             -webkit-backdrop-filter: var(--glass-blur);
             border: 1px solid var(--glass-border);
             box-shadow: var(--glass-shadow);
             text-align: center;
        }

        #sidebar .card .flex.justify-between {
            text-align: left;
        }

        .btn {
            padding-left: 1.5rem;
            padding-right: 1.5rem;
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            font-weight: 600;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition-property: all;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 300ms;
        }
        .btn-primary {
            background-color: var(--highlight-primary);
            color: var(--text-main);
        }
        .btn-primary:hover { filter: brightness(1.2); }
        .btn-danger {
            background-color: var(--status-danger);
            color: var(--text-main);
        }
        .btn-danger:hover { filter: brightness(1.2); }
        .btn-secondary {
            background-color: #4A4A58;
            color: var(--text-main);
        }
        .btn-secondary:hover { background-color: #5A5A68; }


        /* --- 4. Menu Lateral Expansível --- */
        #main-content {
            transition: margin-left 0.3s ease-in-out;
        }
        #sidebar {
            transition: left 0.3s ease-in-out;
            left: -20rem; /* Esconde a sidebar (largura w-80 = 20rem) */
        }
        body.sidebar-open #sidebar {
            left: 0; /* Mostra a sidebar */
        }

        /* Overlay for small screens */
        @media (max-width: 1023px) {
            body.sidebar-open #sidebar-overlay {
                display: block;
            }
        }

        /* Pushing content on large screens */
        @media (min-width: 1024px) {
            body.sidebar-open #main-content {
                margin-left: 20rem;
            }
        }

        #sidebar-toggle-btn {
            z-index: 50;
            transition: left 0.3s ease-in-out;
        }
        body.sidebar-open #sidebar-toggle-btn {
            left: 20.5rem; /* w-80 is 20rem, this pushes it just to the right of the sidebar */
        }
        body.sidebar-open #sidebar-toggle-btn .hamburger-icon {
            display: none;
        }
        body.sidebar-open #sidebar-toggle-btn .close-icon {
            display: block;
        }

        /* --- Visual compacto do menu lateral (apenas ícones), inspirado na referência --- */
        #sidebar { width: 20rem; }
        body.sidebar-open #sidebar { width: 20rem; }
        body.sidebar-open.sidebar-collapsed #sidebar { width: 6rem; }

        /* Ajusta deslocamento do conteúdo e do botão quando colapsado */
        @media (min-width: 1024px) {
            body.sidebar-open.sidebar-collapsed #main-content { margin-left: 6rem; }
        }
        body.sidebar-open.sidebar-collapsed #sidebar-toggle-btn { left: 6.5rem; }

        /* Collapsed: esconde textos e conteúdo das seções, centra os ícones */
        body.sidebar-collapsed #sidebar .collapsible-content { display: none; }
        body.sidebar-collapsed #sidebar .collapsible-header span { display: none; }
        body.sidebar-collapsed #sidebar .collapsible-header { justify-content: center; padding: 0.75rem; }
        body.sidebar-collapsed #sidebar .collapsible-header svg.h-6.w-6 { height: 22px; width: 22px; }
        body.sidebar-collapsed #sidebar .card.collapsible-card { border-radius: 12px; margin: 6px 0; }

        /* Pílula e realce para itens do menu */
        #sidebar .collapsible-header { border-radius: 10px; }
        #sidebar .collapsible-header:hover { background-color: #1a2236; }

        /* --- Menu da referência (expandido e compacto) --- */
        #sidebar .sidebar-search {
            margin: 0.5rem 0 1rem 0;
            background-color: #131a2a;
            border: 1px solid #2a344a;
            border-radius: 10px;
            padding: 0.5rem 0.75rem;
            display: flex; align-items: center; gap: 0.5rem;
            color: #94a3b8;
        }
        #sidebar .sidebar-search input {
            background: transparent;
            border: none;
            outline: none;
            color: #cbd5e1;
            width: 100%;
        }
        #sidebar .menu-list { list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 6px; }
        #sidebar .menu-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            color: #cbd5e1;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #sidebar .menu-item:hover { background-color: #1a2236; }
        #sidebar .menu-item.active { background-color: #eef2ff; color: #0f172a; }
        #sidebar .menu-item .icon { width: 20px; height: 20px; }

        /* Compacto: só ícones, centralizados */
        body.sidebar-collapsed #sidebar .sidebar-search { display: none; }
        body.sidebar-collapsed #sidebar .menu-item { justify-content: center; }
        body.sidebar-collapsed #sidebar .menu-item span { display: none; }
        body.sidebar-collapsed #sidebar .menu-item { padding: 10px; }

        /* Topbar interna da sidebar (marca e botão de recolher) */
        .sidebar-topbar { padding: 0.5rem 0.25rem; display: flex; align-items: center; }
        /* Posição dinâmica do botão: esquerda quando recolhida, direita quando expandida */
        body.sidebar-collapsed #sidebar .sidebar-topbar { justify-content: flex-start; }
        body.sidebar-open:not(.sidebar-collapsed) #sidebar .sidebar-topbar { justify-content: flex-end; }
        .sidebar-brand { color: #e2e8f0; font-weight: 600; letter-spacing: 0.02em; }
        .sidebar-icon-btn {
            display: inline-flex; align-items: center; justify-content: center;

            
            height: 36px; width: 36px; border-radius: 10px;
            background-color: #2D2D3A; color: #cbd5e1;
            border: 1px solid #444459;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }
        .sidebar-icon-btn:hover { background-color: #404052; transform: translateY(-1px); }
        /* Estilo minimalista para o botão Voltar na topbar */
        #sidebar-collapse-btn {
            background-color: rgba(17,24,39,0.28);
            border: 1px solid rgba(255,255,255,0.18);
            color: #e2e8f0;
            box-shadow: none;
        }
        #sidebar-collapse-btn:hover { background-color: rgba(17,24,39,0.36); }
        
        /* Botões de navegação de abas */
        .tab-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255,255,255,0.35);
            border-radius: 12px;
            transition: background-color .2s ease, filter .2s ease, transform .2s ease;
            will-change: transform, filter;
        }
        .tab-button:hover { filter: brightness(1.08); }
        .tab-button:focus { outline: none; box-shadow: 0 0 0 2px rgba(255,255,255,0.25) inset; }
        .tab-button.active {
            background-color: var(--highlight-primary) !important;
            filter: brightness(1.06);
            transform: translateY(0); /* evita corte por overflow */
            box-shadow: 0 0 0 2px rgba(255,255,255,0.25) inset;
        }

        /* --- Elementos Específicos do Dashboard --- */
        .chart-container {
            position: relative;
            width: 100%;
            height: 340px; /* base */
        }
        @media (min-width: 768px) { .chart-container { height: 360px; } }
        .chart-container canvas { height: 100% !important; width: 100% !important; display: block; }

        .form-input-dark {
            display: block;
            width: 100%;
            padding: 0.5rem 1rem 0.5rem 0.75rem;
            font-size: 1rem;
            line-height: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            box-shadow: var(--glass-shadow);
            color: var(--text-main);
            transition: filter .2s ease, box-shadow .2s ease;
        }
        .form-input-dark:hover { filter: brightness(1.04); }
        .form-input-dark:focus {
            outline: 2px solid transparent;
            outline-offset: 2px;
            --tw-ring-color: var(--highlight-primary);
            box-shadow: 0 0 0 2px var(--tw-ring-color);
        }
        .form-input-dark::placeholder { color: var(--text-secondary); opacity: 0.75; }
        .form-input-dark:disabled {
            background: rgba(30,41,59,0.22);
            border-color: rgba(255,255,255,0.1);
            opacity: 0.65;
        }
        
        .modal-overlay {
            position: fixed; inset: 0px; display: flex;
            justify-content: center; align-items: center;
            z-index: 1000; background-color: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(6px);
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            background: var(--glass-bg); padding: 1.25rem;
            border-radius: var(--glass-radius);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            max-width: 42rem; width: 90%; max-height: 80%;
            overflow-y: auto; position: relative;
        }
        .modal-close-btn {
            position: absolute; top: 1rem; right: 1rem;
            background: none; border: none; font-size: 1.5rem;
            cursor: pointer; color: var(--text-secondary);
        }
        .modal-close-btn:hover { color: var(--text-main); }
        .error-item {
            border-left-width: 4px; padding: 0.75rem; margin-bottom: 0.5rem;
            border-radius: 0.25rem; background-color: rgba(213, 0, 0, 0.2);
            border-color: var(--status-danger);
        }
        .error-item strong { color: #ff8a80; }
        .error-item span { color: #ffcdd2; }

        .spinner {
            width: 1.5em; height: 1.5em;
            border: 3px solid rgba(255, 255, 255, .2);
            border-radius: 50%; border-top-color: var(--highlight-primary);
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Estilos da Tabela (Tabulator) --- */
        .tabulator {
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            box-shadow: var(--glass-shadow);
        }
        .tabulator .tabulator-header {
            background: rgba(30, 41, 59, 0.35) !important;
            backdrop-filter: blur(6px) !important;
            border-bottom: 1px solid var(--glass-border) !important;
        }
        .tabulator .tabulator-col, .tabulator .tabulator-col-content {
             background-color: transparent !important;
             /* Padroniza overflow de títulos/headers */
             white-space: nowrap;
             text-overflow: ellipsis;
             overflow: hidden;
        }
        .tabulator .tabulator-col-title {
            color: var(--text-secondary) !important; font-weight: 500;
            white-space: nowrap; text-overflow: ellipsis; overflow: hidden;
        }
        .tabulator .tabulator-header .tabulator-header-filter input {
            background-color: #1C1C24 !important; color: var(--text-main) !important;
            border: 1px solid #4A4A58 !important; border-radius: 8px !important;
            padding: 6px 10px !important;
        }
        .tabulator .tabulator-header .tabulator-header-filter input::placeholder {
             color: var(--text-secondary) !important; opacity: 0.7;
        }
        .tabulator .tabulator-tableHolder {
            background-color: #1C1C24 !important;
            /* Scroll consistente quando conteúdo excede o container */
            overflow: auto !important;
            overscroll-behavior: contain;
        }
        .tabulator .tabulator-placeholder span { color: white !important; }
        .tabulator .tabulator-row {
            background: #1C1C24; border-bottom: 1px solid #2D2D3A !important;
        }
        .tabulator .tabulator-row:hover .tabulator-cell {
            background-color: rgba(58, 127, 255, 0.1) !important;
        }
        .tabulator .tabulator-cell {
            color: var(--text-main) !important;
            border-right: 1px solid #2D2D3A !important;
            padding: 12px 10px !important;
            /* Padroniza overflow das células */
            white-space: nowrap;
            text-overflow: ellipsis;
            overflow: hidden;
        }
        .tabulator .tabulator-cell:last-of-type { border-right: none !important; }
        
        .tabulator .status-success { color: var(--status-success) !important; }
        .tabulator .status-danger { color: var(--status-danger) !important; }
        .tabulator .status-warning { color: var(--highlight-secondary-yellow) !important; }

        /* Scrollbar */
        ::-webkit-scrollbar { height: 10px; width: 10px; }
        ::-webkit-scrollbar-track { background: #1C1C24; }
        ::-webkit-scrollbar-thumb {
            background-color: #4A4A58; border-radius: 5px; border: 2px solid #1C1C24;
        }

        /* Efeito de escurecimento/blur para gráficos quando há seleção */
        canvas.chart-blur-darken {
            filter: blur(1.6px) brightness(0.72);
        }

        /* Tooltip HTML acima do overlay */
        .chart-tooltip {
            position: absolute;
            pointer-events: none;
            z-index: 10; /* acima do overlay (z-index:2) */
            padding: 8px 10px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.85);
            color: #e5e7eb;
            font-size: 12px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.45);
            transform: translate(-50%, -110%);
            white-space: nowrap;
        }
        .chart-tooltip .title { font-weight: 700; color: #e2e8f0; margin-bottom: 2px; }
        .chart-tooltip .body { color: #cbd5e1; }

        /* === NOVAS REGRAS PARA SIDEBAR RECOLHÍVEL E ESTILO REFINADO === */
        
        /* Ajusta o fundo da sidebar para se destacar mais */
        #sidebar {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-right: 1px solid var(--glass-border);
        }
        
        /* Remove o padding padrão do card e ajusta a aparência */
        #sidebar .card.collapsible-card {
            padding: 0;
            background: transparent;
            overflow: hidden; /* Essencial para a animação de altura */
            width: 100%;
        }

        /* Cabeçalho da seção: agora não é interativo (sem expandir/recolher) */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.85rem 1rem; /* estilo mais compacto */
            cursor: default;
            pointer-events: none; /* desativa clique para evitar comportamento de accordion */
            width: 100%;
            transition: background-color 0.2s ease, transform 0.2s ease;
            border-radius: 10px;
        }

        .collapsible-header:hover {
            background-color: rgba(26, 34, 54, 0.35);
            backdrop-filter: blur(6px);
        }
        
        /* Conteúdo das seções: sempre visível (sem comportamento de colapso) */
        .collapsible-content {
            padding: 0 1.25rem 1.25rem 1.25rem;
            max-height: none;
            overflow: visible;
            transition: none;
        }
        
        /* Estado recolhido (sem efeito) */
        .collapsible-content.collapsed {
            max-height: none;
            padding-top: 0;
            padding-bottom: 1.25rem;
        }

        /* Ícone de seta */
        .chevron-icon {
            transition: transform 0.3s ease;
            color: var(--text-secondary);
            display: none; /* oculta seta para não sugerir expandir/recolher */
        }

        /* Estado girado do ícone */
        .chevron-icon.rotated {
            transform: rotate(180deg);
        }

        /* --- Janela flutuante de filtros --- */
        #filters-float-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(2px);
            z-index: 60;
            display: none;
        }
        #filters-float-panel {
            position: fixed;
            top: 12%;
            left: 18%;
            width: 480px;
            min-width: 340px;
            height: auto; /* altura automática para remover scroll interno */
            min-height: 280px;
            /* Glassmorphism: painel translúcido e com blur */
            /* Dark glass mais marcado */
            background: rgba(17, 24, 39, 0.45);
            backdrop-filter: blur(14px) saturate(140%) brightness(0.90);
            -webkit-backdrop-filter: blur(14px) saturate(140%) brightness(0.90);
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.22);
            border-radius: 16px;
            box-shadow: 0 16px 36px rgba(0,0,0,0.45);
            z-index: 70;
            display: none;
        }
        #filters-float-panel .floating-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 0.9rem;
            border-bottom: 1px solid rgba(255,255,255,0.08);
            /* Cabeçalho acompanha o dark glass do painel */
            background: rgba(17, 24, 39, 0.32);
            cursor: move;
            user-select: none;
        }
        #filters-float-panel .floating-title { font-weight: 600; letter-spacing: .01em; }
        #filters-float-panel .floating-actions { display: flex; gap: .5rem; }
        .floating-btn {
            display: inline-flex; align-items: center; justify-content: center;
            width: 34px; height: 34px; border-radius: 10px;
            background: rgba(255,255,255,0.06);
            color: #e2e8f0;
            border: 1px solid rgba(255,255,255,0.20);
        }
        #filters-float-panel .floating-content {
            position: static; /* conteúdo segue o fluxo normal abaixo do cabeçalho */
            padding: 0.75rem 0.9rem;
            overflow: visible; /* sem scroll interno */
        }
        #filters-float-panel .floating-resizer {
            position: absolute; right: 6px; bottom: 6px;
            width: 16px; height: 16px;
            border-right: 2px solid rgba(255,255,255,0.18);
            border-bottom: 2px solid rgba(255,255,255,0.18);
            cursor: nwse-resize;
        }
        /* Dentro da janela flutuante, reabilitar interação do cabeçalho da card p/ drag */
        #filters-float-panel .collapsible-header { pointer-events: auto; cursor: default; }
        /* Minimalismo dentro do painel: cards sem fundo pesado */
        #filters-float-panel .card { background: transparent; box-shadow: none; border: none; padding: 0.5rem; }
        #filters-float-panel .collapsible-header { background: transparent; padding: 0 0 0.5rem 0; border: none; }
        #filters-float-panel .collapsible-content { padding: 0; }
        /* Estado minimizado: mostra apenas o cabeçalho (compacto) */
        #filters-float-panel.minimized { height: auto; width: auto; min-width: 0; }
        #filters-float-panel.minimized .floating-content { display: none; }
        #filters-float-panel.minimized .floating-resizer { display: none; }
        #filters-float-panel.minimized .floating-header { padding: 0.45rem 0.6rem; }
        #filters-float-panel.minimized .floating-title { font-size: 0.95rem; }
        #filters-float-panel.minimized .floating-actions .floating-btn { width: 28px; height: 28px; border-radius: 8px; }

        /* --- Menu rápido flutuante minimalista --- */
        .quick-menu {
            position: fixed;
            right: 16px; bottom: 16px;
            z-index: 55;
            display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .quick-main {
            width: 68px; height: 68px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            background: radial-gradient(circle at 30% 30%, rgba(37,99,235,0.95), rgba(59,130,246,0.85));
            color: #fff; box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.22);
            cursor: pointer; transition: transform .2s ease, box-shadow .2s ease;
        }
        .quick-main:hover { transform: scale(1.05); box-shadow: 0 10px 24px rgba(0,0,0,0.28); }
        .quick-items { display: none; flex-direction: column; align-items: center; gap: 10px; }
        .quick-menu.open .quick-items { display: flex; }
        .quick-item {
            width: 48px; height: 48px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            background: rgba(255,255,255,0.85);
            color: #0f172a; box-shadow: 0 6px 14px rgba(0,0,0,0.20);
            border: 1px solid rgba(255,255,255,0.28);
            cursor: pointer; transition: transform .2s ease, box-shadow .2s ease;
        }
        .quick-item:hover { transform: translateY(-2px); box-shadow: 0 8px 18px rgba(0,0,0,0.22); }
        .quick-tooltip {
            position: absolute; right: 60px;
            background: rgba(17,24,39,0.80); color: #e2e8f0;
            padding: 6px 8px; border-radius: 8px;
            font-size: 12px; white-space: nowrap; pointer-events: none;
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.16);
            opacity: 0; transform: translateX(6px); transition: opacity .15s ease, transform .15s ease;
        }
        .quick-item:hover .quick-tooltip { opacity: 1; transform: translateX(0); }

        @media (max-width: 768px) {
            .quick-menu { right: 12px; bottom: 12px; gap: 8px; }
            .quick-main { width: 62px; height: 62px; }
            .quick-item { width: 44px; height: 44px; }
            .quick-tooltip { right: 56px; }
        }

        /* Oculta botões flutuantes antigos (substituídos pelo menu rápido) */
        #floating-ai-btn, #floating-filter-btn { display: none !important; }
        /* --- Responsivo para Mobile --- */
        @media (max-width: 768px) {
            #filters-float-panel {
                top: 12px;
                left: 12px;
                width: calc(100% - 24px);
                min-width: 300px;
                height: auto; /* ocupa o necessário sem scroll interno */
                border-radius: 14px;
            }
            #filters-float-panel .floating-header {
                padding: 0.65rem 0.8rem;
            }
            #filters-float-panel .floating-content {
                padding: 0.65rem 0.8rem;
            }
            #filters-float-panel .floating-resizer { display: none; }
            #filters-float-panel.minimized {
                width: calc(100% - 24px);
                height: 56px;
            }
            /* Ajustes gerais para compactar cards e gráficos no mobile */
            .card { padding: 0.75rem; }
            .chart-container { height: 300px; }
            .chart-container canvas { height: 100% !important; }
        }

        /* === ESTILOS PARA O DASHBOARD DE TABULAÇÕES === */
        .kpi-card {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--glass-radius);
            padding: 1.25rem;
            text-align: center;
            box-shadow: var(--glass-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px -8px rgb(59 130 246 / 0.4);
        }
        .kpi-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: #94a3b8;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .kpi-value {
            font-size: 2.25rem;
            font-weight: 700;
            color: #3b82f6;
            line-height: 1;
        }
        .chart-card {
            background: var(--glass-bg);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--glass-border);
            border-radius: var(--glass-radius);
            padding: 1.25rem;
            /* Removido overflow: hidden para evitar corte da legenda em gráficos altos */
            box-shadow: var(--glass-shadow);
        }
        .chart-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 1rem;
            text-align: center;
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 360px;
        }
        /* Canvas deve preencher o container para manter alinhamento */
        .chart-container canvas { height: 100% !important; width: 100% !important; display: block; }
    </style>
</head>
<body class="p-4 md:p-8 sidebar-open sidebar-collapsed">

    <!-- BOTÃO DE ALTERNÂNCIA REMOVIDO: página inicia com menu recolhido -->

    <!-- OVERLAY PARA FECHAR A SIDEBAR EM TELAS PEQUENAS -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black/60 z-30 hidden"></div>

    <!-- INÍCIO DO MENU LATERAL CORRIGIDO -->
    <aside id="sidebar" class="fixed top-0 h-full w-80 bg-gray-900 z-40 overflow-y-auto p-4">
        <!-- Barra superior interna da sidebar: marca e botão de recolher -->
        <div class="sidebar-topbar flex items-center justify-between">
            
            <button id="sidebar-collapse-btn" class="sidebar-icon-btn" title="Expandir">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
                </svg>
            </button>
        </div>
        <div class="sidebar-inner">
            <ul class="menu-list">
                <li id="menu-upload-pauses-btn" class="menu-item active">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 4v16" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M15 4v16" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <span>Upload Pausas</span>
                </li>
                <li id="menu-upload-tabs-btn" class="menu-item">
                    <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 4h12a2 2 0 0 1 2 2v14l-8-4-8 4V6a2 2 0 0 1 2-2z" />
                    </svg>
                    <span>Upload Tabulações</span>
                </li>
            </ul>
            <div id="sidebar-functional-blocks" class="flex flex-col gap-4 mt-2 lg:mt-0 hidden">
            <!-- PAUSES CONTROLS -->
            <div id="pauses-sidebar-content" class="flex flex-col gap-4">
                <div id="pauses-upload-card" class="card collapsible-card">
                    <div class="collapsible-header">
                        <h2 class="text-2xl font-semibold text-slate-100 flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9 4v16" stroke-linecap="round" stroke-linejoin="round" />
                                <path d="M15 4v16" stroke-linecap="round" stroke-linejoin="round" />
                            </svg>
                            <span>Carregar Dados de Pausas</span>
                        </h2>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 chevron-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="collapsible-content">
                        <div class="flex flex-col gap-4">
                            <div>
                                <label class="block text-sm font-medium text-slate-300 mb-2">Arquivo CSV de Pausas</label>
                                <div class="flex justify-center">
                                    <label id="file-upload-label" for="csv-file-input" class="w-full cursor-pointer px-4 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 transition duration-300 ease-in-out truncate text-center">
                                        Escolher arquivo
                                    </label>
                                    <input type="file" id="csv-file-input" accept=".csv, .txt" class="hidden" />
                                </div>
                            </div>
                            <p id="file-status" class="text-sm text-slate-400 mt-4">Nenhum dado carregado.</p>
                        </div>
                    </div>
                </div>

                <div id="pauses-filters-card" class="card collapsible-card">
                    <div class="collapsible-header">
                        <h2 class="text-2xl font-semibold text-slate-100 flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293.707L3.293 7.293A1 1 0 013 6.586V4z" />
                            </svg>
                            <span>Filtros de Pausas</span>
                        </h2>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 chevron-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="collapsible-content">
                        <div class="flex flex-col gap-4">
                            <div class="flex flex-col gap-1">
                                <label for="consultant-filter" class="text-sm font-medium text-slate-300">Consultor:</label>
                                <select id="consultant-filter" class="form-input-dark w-full" disabled>
                                    <option value="">Todos</option>
                                </select>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="pause-type-filter" class="text-sm font-medium text-slate-300">Tipo de Pausa:</label>
                                <select id="pause-type-filter" class="form-input-dark w-full" disabled>
                                    <option value="">Todos</option>
                                </select>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="start-date-filter" class="text-sm font-medium text-slate-300">Data Início:</label>
                                <input type="date" id="start-date-filter" class="form-input-dark w-full" disabled>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="end-date-filter" class="text-sm font-medium text-slate-300">Data Fim:</label>
                                <input type="date" id="end-date-filter" class="form-input-dark w-full" disabled>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="tabulations-sidebar-content" class="flex flex-col gap-4 hidden">
                <div class="card collapsible-card">
                    <div class="collapsible-header">
                        <h2 class="text-2xl font-semibold text-slate-100 flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                            <span>Carregar Dados de Tabulações</span>
                        </h2>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 chevron-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="collapsible-content">
                        <div class="flex flex-col gap-4">
                            <div>
                                <label class="block text-sm font-medium text-slate-300 mb-2">Arquivo CSV de Tabulações</label>
                                <div class="flex justify-center">
                                    <label id="call-tabulations-file-upload-label" for="call-tabulations-csv-file-input" class="w-full cursor-pointer px-4 py-2 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 transition duration-300 ease-in-out truncate text-center">
                                        Escolher arquivo
                                    </label>
                                    <input type="file" id="call-tabulations-csv-file-input" accept=".csv, .txt, .tsv" class="hidden"/>
                                </div>
                            </div>
                            <p id="call-tabulations-file-status" class="text-sm text-slate-400 mt-4">Nenhum dado carregado.</p>
                        </div>
                    </div>
                </div>

                <div id="tabulations-filters-card" class="card collapsible-card">
                    <div class="collapsible-header">
                        <h2 class="text-2xl font-semibold text-slate-100 flex items-center gap-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293.707L3.293 7.293A1 1 0 013 6.586V4z" />
                            </svg>
                            <span>Filtros de Tabulações</span>
                        </h2>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 chevron-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                        </svg>
                    </div>
                    <div class="collapsible-content">
                        <div class="flex flex-col gap-4">
                            <div class="flex flex-col gap-1">
                                <label for="tabulation-operator-filter" class="text-sm font-medium text-slate-300">Operador:</label>
                                <select id="tabulation-operator-filter" class="form-input-dark w-full" disabled>
                                    <option value="">Todos</option>
                                </select>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="tabulation-type-filter" class="text-sm font-medium text-slate-300">Tipo de Tabulação:</label>
                                <select id="tabulation-type-filter" class="form-input-dark w-full" disabled>
                                    <option value="">Todos</option>
                                </select>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="tabulation-category-filter" class="text-sm font-medium text-slate-300">Categoria:</label>
                                <select id="tabulation-category-filter" class="form-input-dark w-full" disabled>
                                    <option value="">Todas</option>
                                </select>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="call-tabulations-start-date-filter" class="text-sm font-medium text-slate-300">Data Início:</label>
                                <input type="date" id="call-tabulations-start-date-filter" class="form-input-dark w-full date-input" data-placeholder="dd/mm/aaaa" disabled required>
                            </div>
                            <div class="flex flex-col gap-1">
                                <label for="call-tabulations-end-date-filter" class="text-sm font-medium text-slate-300">Data Fim:</label>
                                <input type="date" id="call-tabulations-end-date-filter" class="form-input-dark w-full date-input" data-placeholder="dd/mm/aaaa" disabled required>
                            </div>
                        </div>
                        <div class="flex flex-col gap-4 mt-6">
                            <button id="call-tabulations-clear-filters-btn" class="w-full px-6 py-3 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-300 ease-in-out" disabled>
                                Limpar Filtros
                            </button>
                        </div>
                    </div>
                </div>
            </div>


        </div>
    </aside>
    <!-- FIM DO MENU LATERAL -->

    <main id="main-content">
        <div class="container mx-auto">
            
            <div class="flex justify-center mb-8 space-x-4">
                <button id="tab-pauses-btn" class="tab-button active px-6 py-3 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 transition duration-300 ease-in-out">
                    Pausas
                </button>
                <button id="tab-call-tabulations-btn" class="tab-button px-6 py-3 bg-slate-700 text-white font-semibold rounded-lg shadow-md hover:bg-slate-600 transition duration-300 ease-in-out">
                    Tabulações de Ligações
                </button>
            </div>

            <div id="pauses-dashboard-content">
    
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                <div class="kpi-card">
                    <h3 class="kpi-title">Pausas Registradas</h3>
                    <p id="kpi-total-pauses" class="kpi-value">0</p>
                </div>
                <div class="kpi-card">
                    <h3 class="kpi-title">Total Global de Pausa</h3>
                    <p id="kpi-total-global-pause" class="kpi-value">00:00</p>
                </div>
                <div class="kpi-card">
                    <h3 class="kpi-title">Consultores Únicos</h3>
                    <p id="kpi-unique-consultants" class="kpi-value">0</p>
                </div>
            </div>
    
            <div class="flex flex-col gap-6">
                <div id="ai-analysis-section" class="card hidden">
                    <h2 class="text-2xl font-semibold text-slate-100 mb-4">Análise de Pausas com IA</h2>
                    <div id="ai-analysis-content" class="bg-slate-900/50 p-4 rounded-lg text-slate-300 leading-relaxed min-h-[100px] flex items-center justify-center">
                        <p id="ai-loading-message" class="hidden text-center text-slate-400 flex items-center justify-center">
                            <div class="spinner mr-2"></div> Gerando análise... por favor, aguarde.
                        </p>
                        <p id="ai-placeholder-message" class="text-center text-slate-400">
                            Selecione um consultor e um período (opcional) e clique em "Gerar Análise com IA ✨" para ver um resumo personalizado.
                        </p>
                    </div>
                    <button id="close-ai-analysis-btn" class="mt-4 px-4 py-2 bg-slate-600 text-slate-100 font-semibold rounded-lg shadow-md hover:bg-slate-700 transition duration-300 ease-in-out">
                        Fechar Análise
                    </button>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div class="chart-card">
                        <h3 class="chart-title">Total de Duração por Consultor</h3>
                        <div class="chart-container">
                            <canvas id="total-pause-consultant-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h3 class="chart-title">Total de Duração por Tipo</h3>
                        <div class="chart-container">
                            <canvas id="total-pause-type-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h3 class="chart-title">Média de Duração por Tipo</h3>
                        <div class="chart-container">
                            <canvas id="average-pause-type-chart"></canvas>
                        </div>
                    </div>
                    <div class="chart-card">
                        <h3 class="chart-title">Distribuição do Tempo por Tipo</h3>
                        <div class="chart-container">
                            <canvas id="pause-type-distribution-chart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2 class="text-2xl font-semibold text-slate-100 mb-4">Detalhes das Pausas</h2>
                    <div id="pause-detail-table" data-bs-theme="dark" class="table-dark"></div>
                </div>
            </div>
        </div>
        <div id="call-tabulations-dashboard-content" class="hidden p-2 sm:p-4 md:p-6">
            <!-- KPIs for Call Tabulations -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                <div class="kpi-card">
                    <h3 class="kpi-title">Total de Tabulações</h3>
                    <p id="total-tabulations-kpi" class="kpi-value">0</p>
                </div>
                <div class="kpi-card">
                    <h3 class="kpi-title">Operadores Únicos</h3>
                    <p id="unique-operators-kpi" class="kpi-value">0</p>
                </div>
                <div class="kpi-card">
                    <h3 class="kpi-title">Média de Tabulações por Dia</h3>
                    <p id="avg-tabulations-day-kpi" class="kpi-value">0</p>
                </div>
            </div>
        
            <!-- Charts for Call Tabulations -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-6">
            <div class="chart-card">
                <h3 class="chart-title">Total de Tabulações por Operador</h3>
                <div class="chart-container">
                    <canvas id="total-tabulations-operator-chart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">Total de Tabulações por Tipo</h3>
                <div class="chart-container">
                    <canvas id="total-tabulations-type-chart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">Total de Tabulações por Categoria</h3>
                <div class="chart-container">
                    <canvas id="total-tabulations-category-chart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">Distribuição de Tabulações por Tipo</h3>
                <div class="chart-container">
                    <canvas id="tabulation-type-distribution-chart"></canvas>
                </div>
            </div>
            </div>
        
            <!-- Table for Call Tabulations -->
            <div class="bg-slate-800/50 rounded-lg p-4 border border-slate-700">
                <h3 class="text-xl font-bold text-slate-200 mb-4">Detalhes das Tabulações</h3>
                <div id="call-tabulations-detail-table"></div>
            </div>
        </div>
    </div>


    </main>

    <!-- Overlay e Janela Flutuante de Filtros -->
    <div id="filters-float-overlay"></div>
    <div id="filters-float-panel" aria-modal="true" role="dialog">
        <div class="floating-header">
            <span class="floating-title">Filtros</span>
            <div class="floating-actions">
                <button id="filters-float-minimize-btn" class="floating-btn" title="Minimizar">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14" />
                    </svg>
                </button>
                <button id="filters-float-close-btn" class="floating-btn" title="Fechar">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
        </div>
        <div id="filters-float-content" class="floating-content"></div>
        <div class="floating-resizer" aria-hidden="true"></div>
    </div>

    <div id="ignored-rows-modal-overlay" class="modal-overlay hidden">
        <div class="modal-content">
            <button id="close-ignored-rows-modal-btn" class="modal-close-btn">&times;</button>
            <h3 class="text-xl font-bold text-red-400 mb-4">⚠️ <span id="ignored-rows-count">0</span> Linhas Ignoradas no CSV</h3>
            <p class="text-slate-300 mb-4">As seguintes linhas foram ignoradas devido a dados inválidos ou ausentes. Por favor, revise seu arquivo CSV.</p>
            <ul id="ignored-rows-list" class="space-y-2"></ul>
        </div>
    </div>


    <script>
        // --- Configuração Global ---
        let geminiApiKey = null;        const COLUMN_ALIASES = {
            'GRUPO_OPERACIONAL': ['GRUPO OPERACIONAL', 'GRUPO OP'],
            'OPERADOR': ['OPERADOR', 'CONSULTOR', 'NOME DO OPERADOR', 'NOME OPERADOR'],
            'ESTADO': ['ESTADO'],
            'DESCRICAO_PAUSA': ['DESCRICAO DA PAUSA', 'DESCRIÇÃO DA PAUSA', 'TIPO PAUSA', 'TIPO_PAUSA', 'PAUSA', 'MOTIVO PAUSA', 'MOTIVO_PAUSA'],
            'DATA_INICIO': ['INICIO', 'DATA INICIO', 'DATA_INICIO', 'DATA_HORA_INICIO', 'DATA HORA INICIO'],
            'DATA_FIM': ['FIM', 'DATA FIM', 'DATA_FIM', 'DATA_HORA_FIM', 'DATA HORA FIM'],
            'TEMPO_PAUSA': ['TEMPO', 'TEMPO PAUSA', 'TEMPO_PAUSA', 'TEMPO_TOTAL_PAUSA', 'TEMPO TOTAL PAUSA'],
            'INICIO_LIVRE': ['INICIO EM LIVRE'],
            'SEGUNDOS_EM_LIVRE': ['SEGUNDOS EM LIVRE'],
            'DURACAO_ESPERADA': ['DURACAO ESPERADA', 'DURACAO_ESPERADA']
        };

        const columnAliasesCallTabulations = {
            'NR_LEAD': ['NR. LEAD', 'NR.LEAD', 'NR LEAD', 'NR_LEAD', 'LEAD'],
            'DATA_HORA_TABULACAO': ['Data/Hora Tabulação', 'DATA/HORA TABULAÇÃO', 'DATA/HORA_TABULACAO', 'DATA HORA TABULACAO', 'DATA_HORA_TABULACAO', 'DATA', 'HORA', 'DATA E HORA'],
            'TIPO_AGENDA': ['TIPO AGENDA (SALVOU)', 'TIPO_AGENDA', 'AGENDA'],
            'TABULADO_COMO': ['Tabulado Como', 'TABULADO COMO', 'TABULADO_COMO', 'STATUS'],
            'CATEGORIA_TABULACAO': ['Categoria Tabulação', 'CATEGORIA TABULAÇÃO', 'CATEGORIA_TABULACAO', 'CATEGORIA'],
            'OPERADOR': ['OPERADOR', 'CONSULTOR', 'NOME DO OPERADOR', 'NOME OPERADOR'],
            'COD_LOTE': ['Cód. Lote', 'CÓD. LOTE', 'COD. LOTE', 'COD LOTE', 'COD_LOTE', 'LOTE ID'],
            'LOTE': ['LOTE', 'DESCRICAO LOTE'],
            'NOME_CLIENTE': ['Nome do Cliente', 'NOME DO CLIENTE', 'NOME_CLIENTE', 'CLIENTE'],
            'DATA_IMPORTACAO': ['Data Importação', 'DATA IMPORTAÇÃO', 'DATA_IMPORTACAO', 'IMPORTACAO'],
            'CPF_CNPJ': ['CPF / CNPJ', 'CPF/CNPJ', 'CPF_CNPJ', 'DOCUMENTO'],
            'COD_CLIENTE': ['Cód. Cliente', 'CÓD. CLIENTE', 'COD. CLIENTE', 'COD CLIENTE', 'COD_CLIENTE', 'ID CLIENTE'],
            'TELEFONE': ['TELEFONE', 'FONE'],
            'ORIGEM_TABULACAO': ['Origem Tabulação', 'ORIGEM TABULAÇÃO', 'ORIGEM_TABULACAO', 'ORIGEM'],
            'ORIGEM_POPUP': ['Origem Popup', 'ORIGEM POPUP', 'ORIGEM_POPUP'],
            'GRUPO_USUARIO': ['Grupo Usuário', 'GRUPO USUÁRIO', 'GRUPO_USUARIO'],
            'INFORMACAO_ATENDIMENTO': ['Informação do Atendimento', 'INFORMAÇÃO DO ATENDIMENTO', 'INFORMACAO_ATENDIMENTO'],
        };
        // Aliases extras para maior compatibilidade com variações de cabeçalho
        columnAliasesCallTabulations['DATA_HORA_TABULACAO'].push('DATA HORA', 'DATA/HORA', 'DATA_HORA', 'DATA HORA TABULAÇÃO', 'DATA HORA TABULACAO', 'DT TABULAÇÃO', 'DT TABULACAO', 'DT/HORA');
        columnAliasesCallTabulations['TABULADO_COMO'].push('STATUS FINAL', 'TABULAÇÃO', 'TABULACAO', 'RESULTADO');
        columnAliasesCallTabulations['CATEGORIA_TABULACAO'].push('CATEGORIA FINAL', 'CATEGORIA DO STATUS', 'CLASSE');
        columnAliasesCallTabulations['OPERADOR'].push('USUÁRIO', 'USUARIO', 'ATENDENTE', 'AGENTE', 'OPERADOR(A)', 'NOME DO ATENDENTE', 'NOME AGENTE', 'NOME CONSULTOR');
        
        const expectedDurations = {
            'Almoço': { minutes: 60, tolerance: 3 },
            'Café': { minutes: 15, tolerance: 2 },
            'Intervalo': { minutes: 15, tolerance: 2 },
            'Pausa Intervalo': { minutes: 15, tolerance: 2 },
            'Banheiro': { minutes: 10, tolerance: 3 },
            'Negociação': { minutes: 15, tolerance: 3 },
            'Em Negociação': { minutes: 15, tolerance: 3 },
            'Cadastrando Proposta': { minutes: 5, tolerance: 2 },
            'Pesquisando Lead': { minutes: 5, tolerance: 2 },
            'Novo Lead': { minutes: 5, tolerance: 2 }
        };

        // Objeto unificado para seletores do DOM
        const els = {
            main: {
                tabPausasBtn: document.getElementById('tab-pauses-btn'),
                tabCallTabulationsBtn: document.getElementById('tab-call-tabulations-btn'),
                pausesDashboardContent: document.getElementById('pauses-dashboard-content'),
                fileInput: document.getElementById('csv-file-input'),
                fileUploadLabel: document.getElementById('file-upload-label'),
                fileStatus: document.getElementById('file-status'),
                pauseDetailsTable: null, // Será inicializado com o Tabulator
                buttons: {
                    loadArgusApi: document.getElementById('load-argus-api-btn'),
                    generateAi: document.getElementById('generate-ai-analysis-btn'),
                    clearFilters: document.getElementById('clear-filters-btn'),
                    closeAi: document.getElementById('close-ai-analysis-btn'),
                },
                filters: {
                    consultant: document.getElementById('consultant-filter'),
                    pauseType: document.getElementById('pause-type-filter'),
                    startDate: document.getElementById('start-date-filter'),
                    endDate: document.getElementById('end-date-filter'),
                },
                apiControls: {
                    startDate: document.getElementById('argus-start-date'),
                    endDate: document.getElementById('argus-end-date'),
                    startTime: document.getElementById('argus-start-time'),
                    endTime: document.getElementById('argus-end-time'),
                },
                kpis: {
                    totalPauses: document.getElementById('kpi-total-pauses'),
                    totalDuration: document.getElementById('kpi-total-global-pause'),
                    uniqueConsultants: document.getElementById('kpi-unique-consultants')
                },
                ignoredRowsModal: {
                    overlay: document.getElementById('ignored-rows-modal-overlay'),
                    modal: document.getElementById('ignored-rows-modal'),
                    count: document.getElementById('ignored-rows-count'),
                    list: document.getElementById('ignored-rows-list'),
                    closeBtn: document.getElementById('close-ignored-rows-modal-btn'),
                },
                ai: {
                    section: document.getElementById('ai-analysis-section'),
                    loading: document.getElementById('ai-analysis-loading'),
                    placeholder: document.getElementById('ai-analysis-placeholder'),
                    content: document.getElementById('ai-analysis-content'),
                }
            },
            callTabulations: {
                dashboardContent: document.getElementById('call-tabulations-dashboard-content'),
                fileInput: document.getElementById('call-tabulations-csv-file-input'),
                fileUploadLabel: document.getElementById('call-tabulations-file-upload-label'),
                fileStatus: document.getElementById('call-tabulations-file-status'),
                tableContainer: document.getElementById('call-tabulations-detail-table'),
                buttons: {
                    clearFilters: document.getElementById('call-tabulations-clear-filters-btn'),
                },
                filters: {
                    operator: document.getElementById('tabulation-operator-filter'),
                    type: document.getElementById('tabulation-type-filter'),
                    category: document.getElementById('tabulation-category-filter'),
                    startDate: document.getElementById('call-tabulations-start-date-filter'),
                    endDate: document.getElementById('call-tabulations-end-date-filter'),
                },
                kpis: {
                    total: document.getElementById('total-tabulations-kpi'),
                    uniqueOperators: document.getElementById('unique-operators-kpi'),
                    avgPerDay: document.getElementById('avg-tabulations-day-kpi'),
                }
            }
        };

        let originalData = [];
        let filteredData = [];
        let callTabulationsOriginalData = [];
        let callTabulationsFilteredData = [];

        let tabulatorTable = null;
        let callTabulationsTable = null;
        let filteredAveragesForComparison = {};

        let charts = {
            consultantTotal: null,
            typeTotal: null,
            typeAverage: null,
            typeDistribution: null,
            tabulationOperatorTotal: null,
            tabulationTypeTotal: null,
            tabulationCategoryTotal: null,
            tabulationTypeDistribution: null
        };

        // Seleção dinâmica para cross-filter em Pausas
        let dashboardSelection = { 
            consultant: null,
            pauseType: null,
            tabOperator: null,
            tabType: null,
            tabCategory: null
        };

        // --- Funções Utilitárias ---
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }
        function parseDurationToMinutes(durationStr) {
            if (!durationStr) return 0;
            const cleanStr = durationStr.trim().replace(/^"|"$/g, '');
            const parts = cleanStr.split(':').map(Number);
            if (parts.length === 3) { return parts[0] * 60 + parts[1] + parts[2] / 60; }
            else if (parts.length === 2) { return parts[0] * 60 + parts[1]; }
            return 0;
        }
        function formatMinutesToHHMM(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }
        function formatMinutesToHHMMSS(totalMinutes) {
            if (isNaN(totalMinutes) || totalMinutes < 0) return '00:00:00';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = Math.floor(totalMinutes % 60);
            const seconds = Math.round((totalMinutes - Math.floor(totalMinutes)) * 60);
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function normalizeHeader(str) {
            if (typeof str !== 'string') return '';
            return str.toLowerCase().normalize('NFD').replace(/[̀-ͯ]/g, '').replace(/[^a-z0-9]/g, '');
        }
        function normalizeDataString(str) {
            if (!str) return 'Não informado';
            return str.trim().replace(/\s+/g, ' ');
        }
        function toTitleCase(str) {
            if (!str || str === 'Não informado') return str;
            return str.toLowerCase().split(' ').map(word => {
                if (word.length === 0) return '';
                return word.charAt(0).toUpperCase() + word.slice(1);
            }).join(' ');
        }
        function parseDateTimeRobust(dateTimeStr) {
            if (!dateTimeStr || typeof dateTimeStr !== 'string' || dateTimeStr.trim() === '' || dateTimeStr.includes('#########') || dateTimeStr.includes('#')) { return null; }
            let cleanStr = dateTimeStr.trim().replace(/^"|"$/g, '');
            let date = new Date(cleanStr);
            if (!isNaN(date.getTime())) return date;
            const brRegex = /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\s+(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?/;
            const match = cleanStr.match(brRegex);
            if (match) {
                const day = parseInt(match[1], 10);
                const month = parseInt(match[2], 10) - 1;
                const year = parseInt(match[3], 10);
                const hour = parseInt(match[4], 10);
                const minute = parseInt(match[5], 10);
                const second = match[6] ? parseInt(match[6], 10) : 0;
                date = new Date(year, month, day, hour, minute, second);
                if (!isNaN(date.getTime())) return date;
            }
            return null;
        }
        function formatDateToYYYYMMDD(date) {
            if (!date || isNaN(date.getTime())) return '';
            return date.toISOString().split('T')[0];
        }
        function formatDateTimeDisplay(date) {
            if (!date || isNaN(date.getTime())) return '';
            return date.toLocaleString('pt-BR', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        }
        function splitCsvLine(line, delimiter) {
            const regex = new RegExp(`${delimiter}(?=(?:(?:[^\"]*\"){2})*[^\"]*$)`);
            let values = line.split(regex);
            values = values.map(val => {
                let trimmed = val.trim();
                if (trimmed.length > 1 && trimmed.startsWith('"') && trimmed.endsWith('"')) {
                    trimmed = trimmed.substring(1, trimmed.length - 1);
                    trimmed = trimmed.replace(/""/g, '"');
                }
                return trimmed;
            });
            return values;
        }
        
        function abbreviateName(fullName, maxLength = 18) {
            if (typeof fullName !== 'string') return fullName;
            const normalized = fullName.trim().replace(/\s+/g, ' ');
            const parts = normalized.split(' ').filter(p => p.length > 0);
            const first = parts[0] || normalized;
            // Mostrar somente o primeiro nome; ocultar sobrenomes
            if (first.length <= maxLength) return first;
            // Se o primeiro nome for muito longo, cortar mantendo apenas ele
            return first.substring(0, maxLength);
        }

        // Abrevia rótulos longos para legendas de gráficos (ex.: tabulações)
        function abbreviateLabel(text, maxLength = 18) {
            if (typeof text !== 'string') return text;
            const t = text.trim();
            if (t.length <= maxLength) return t;
            const known = {
                'CLIENTE NAO SE ENCONTRA': 'CLT. NAO ENCONTRA',
                'CLIENTE NÃO SE ENCONTRA': 'CLT. NÃO ENCONTRA',
                'EXCESSO DE TENTATIVA': 'EXC. TENTATIVA',
                'NAO CONSEGUI REVERTER': 'NAO REVERTEU',
                'NÃO CONSEGUI REVERTER': 'NÃO REVERTEU',
                'QUASE FECHEI (RETORNAR)': 'QUASE FECHOU (RET)',
                'SEM TELEFONES PARA DISCAR': 'SEM TEL. P/ DISCAR',
                'PROPOSTA ENVIADA': 'PROP. ENVIADA',
                'LIGACAO MUDA': 'LIG. MUDA',
                'LIGAÇÃO MUDA': 'LIG. MUDA',
                'CAIXA POSTAL': 'CX. POSTAL',
                'CLIENTE DESLIGOU': 'CLT. DESLIGOU',
                'EM NEGOCIACAO': 'NEGOCIACAO',
                'EM NEGOCIAÇÃO': 'NEGOCIAÇÃO',
                'IDADE MAXIMA': 'IDADE MÁX.',
                'IDADE MÁXIMA': 'IDADE MÁX.'
            };
            const upper = t.toUpperCase();
            if (known[upper]) return known[upper];
            const words = t.split(/\s+/).filter(Boolean).map(w => w.length > 8 ? (w.slice(0, 5) + '.') : w);
            let out = words.join(' ');
            if (out.length > maxLength) out = out.slice(0, maxLength - 1) + '…';
            return out;
        }

        // --- Processamento de Dados ---
        function detectDelimiter(firstLine) {
            // Não considerar espaço como delimitador para evitar detecções falsas
            const delimiters = [';', ',', '\t', '|'];
            let bestDelimiter = null;
            let maxCount = 0;
            delimiters.forEach(delim => {
                const count = firstLine.split(delim).length;
                if (count > maxCount) {
                    maxCount = count;
                    bestDelimiter = delim;
                }
            });
            return maxCount > 1 ? bestDelimiter : null;
        }

        function mapHeaders(rawHeaders, aliases) {
            const headerMap = {};
            const normalize = (str) => str ? str.trim().toUpperCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '') : '';

            const normalizedRawHeaders = rawHeaders.map(normalize);

            for (const key in aliases) {
                const aliasList = aliases[key];
                let found = false;
                // Match exato primeiro
                for (const alias of aliasList) {
                    const normalizedAlias = normalize(alias);
                    const headerIndex = normalizedRawHeaders.indexOf(normalizedAlias);
                    if (headerIndex !== -1) {
                        headerMap[key] = rawHeaders[headerIndex];
                        found = true;
                        break;
                    }
                }
                // Fallback: correspondência parcial
                if (!found) {
                    for (let i = 0; i < normalizedRawHeaders.length && !found; i++) {
                        const hdr = normalizedRawHeaders[i];
                        for (const alias of aliasList) {
                            const normalizedAlias = normalize(alias);
                            if (hdr.includes(normalizedAlias) || normalizedAlias.includes(hdr)) {
                                headerMap[key] = rawHeaders[i];
                                found = true;
                                break;
                            }
                        }
                    }
                }
            }
            
            return headerMap;
        }

        function processData(csvContent) {
            console.log('Iniciando processamento inteligente do CSV...');
            els.main.fileStatus.className = 'text-sm text-slate-400 mt-4';
            els.main.ignoredRowsModal.overlay.classList.add('hidden');

            if (!csvContent || !csvContent.trim()) {
                handleDataLoadError('Arquivo vazio.');
                return;
            }

            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }

            const lines = csvContent.trim().split(/\r\n|\n|\r/);
            if (lines.length < 2) {
                handleDataLoadError('Arquivo contém apenas cabeçalho ou está vazio.');
                return;
            }

            const delimiter = detectDelimiter(lines[0]);
            if (!delimiter) {
                handleDataLoadError('Não foi possível detectar o separador de colunas (vírgula, ponto e vírgula ou tabulação).');
                return;
            }
            
            let rawHeaders = splitCsvLine(lines[0], delimiter);
            let emptyCellOffset = 0;
            if (rawHeaders.length > 0 && rawHeaders[0].trim() === '') {
                rawHeaders = rawHeaders.slice(1);
                emptyCellOffset = 1;
            }

            console.log('Raw Headers from CSV (after potential trim):', rawHeaders);
            const headerMap = mapHeaders(rawHeaders, COLUMN_ALIASES);

            // Cabeçalhos mínimos necessários para funcionamento do dashboard de pausas
            // Tornamos opcionais campos como GRUPO_OPERACIONAL, ESTADO, INICIO_LIVRE, SEGUNDOS_EM_LIVRE e DATA_FIM,
            // pois não são usados nos KPIs/gráficos principais.
            const requiredHeaders = ['OPERADOR', 'DESCRICAO_PAUSA', 'DATA_INICIO', 'TEMPO_PAUSA'];
            const missingHeaders = requiredHeaders.filter(h => !headerMap[h]);

            if (missingHeaders.length > 0) {
                 const missingNames = missingHeaders.map(k => COLUMN_ALIASES[k].join(' ou ')).join('; \n');
                 handleDataLoadError(`Não foi possível encontrar colunas correspondentes a:\n${missingNames}.\nVerifique os cabeçalhos do seu CSV.`);
                 return;
            }

            const headerIndexes = {};
            for(const key in headerMap) {
                const rawHeaderIndex = rawHeaders.indexOf(headerMap[key]);
                if (rawHeaderIndex !== -1) {
                    headerIndexes[key] = rawHeaderIndex;
                }
            }

            let ignoredRowsDetails = [];

            originalData = lines.slice(1).map((line, index) => {
                const currentLineNumber = index + 2;
                if (!line.trim()) return null;
                let values = splitCsvLine(line, delimiter);
                if (emptyCellOffset > 0) {
                    values = values.slice(emptyCellOffset);
                }

                // A verificação de colunas deve considerar o offset da célula vazia
                if (values.length < rawHeaders.length) {
                    ignoredRowsDetails.push({ lineNumber: currentLineNumber, reason: 'Número de colunas diferente do cabeçalho', columnName: 'Linha Completa', columnValue: line.substring(0, 150) + (line.length > 150 ? '...' : '') });
                    return null;
                }

                const getColumnValue = (key) => values[headerIndexes[key]] || '';

                const rawDuration = getColumnValue('TEMPO_PAUSA');
                const durationMinutes = parseDurationToMinutes(rawDuration);
                const dateRawValue = getColumnValue('DATA_INICIO');
                const dateObj = parseDateTimeRobust(dateRawValue);
                const operadorRawValue = getColumnValue('OPERADOR');
                const operador = normalizeDataString(operadorRawValue);
                const tipoRawValue = getColumnValue('DESCRICAO_PAUSA');
                const tipo = toTitleCase(normalizeDataString(tipoRawValue));

                let rowProblem = null;
                if (!dateObj) rowProblem = { reason: `Data/Hora de Início inválida ou vazia`, columnName: headerMap.DATA_INICIO, columnValue: dateRawValue };
                else if (durationMinutes <= 0) rowProblem = { reason: `Duração da pausa inválida ou zero`, columnName: headerMap.TEMPO_PAUSA, columnValue: rawDuration };
                else if (operador === 'Não informado' || operadorRawValue.trim() === '') rowProblem = { reason: `Nome do Operador não informado`, columnName: headerMap.OPERADOR, columnValue: operadorRawValue };
                else if (tipo === 'Não informado' || tipoRawValue.trim() === '') rowProblem = { reason: `Descrição da Pausa não informada`, columnName: headerMap.DESCRICAO_PAUSA, columnValue: tipoRawValue };

                if (rowProblem) {
                    ignoredRowsDetails.push({ lineNumber: currentLineNumber, ...rowProblem });
                    return null;
                }

                return {
                    GRUPO_OPERACIONAL: getColumnValue('GRUPO_OPERACIONAL'),
                    CONSULTOR: operador,
                    ESTADO: getColumnValue('ESTADO'),
                    TIPO: tipo,
                    DATA_INICIO_OBJ: dateObj,
                    DATA_FIM: parseDateTimeRobust(getColumnValue('DATA_FIM')),
                    DURACAO_MINUTES: durationMinutes,
                    INICIO_LIVRE: getColumnValue('INICIO_LIVRE'),
                    SEGUNDOS_EM_LIVRE: getColumnValue('SEGUNDOS_EM_LIVRE'),
                    _raw: { duration: rawDuration, date: dateRawValue }
                };
            }).filter(row => row !== null);

            if (originalData.length === 0) {
                if (ignoredRowsDetails.length > 0) showIgnoredRowsPopup(ignoredRowsDetails);
                handleDataLoadError('Nenhuma linha de dados válida encontrada após o processamento.');
                return;
            }

            const dates = originalData.map(d => d.DATA_INICIO_OBJ);
            if (els.main.filters.startDate) {
                els.main.filters.startDate.value = formatDateToYYYYMMDD(new Date(Math.min(...dates)));
            }
            if (els.main.filters.endDate) {
                els.main.filters.endDate.value = formatDateToYYYYMMDD(new Date(Math.max(...dates)));
            }

            filteredData = [...originalData];
            populateFilters();
            enableDashboardControls(true);
            const exportButton = document.getElementById('export-html-btn');
            if (exportButton) {
                exportButton.disabled = false; // Habilitar botão de exportar
            }

            let statusMsg = `Sucesso! Separador: [${delimiter === '\t' ? 'TAB' : delimiter}]. Carregados ${originalData.length} registros.`;
            if (ignoredRowsDetails.length > 0) {
                statusMsg += ` (${ignoredRowsDetails.length} linhas ignoradas).`;
                showIgnoredRowsPopup(ignoredRowsDetails);
            }

            els.main.fileStatus.textContent = statusMsg;
            els.main.fileStatus.className = 'text-sm text-green-400 mt-4 font-medium';
            updateDashboard();
        }

        function transformArgusData(apiData) {
            if (!Array.isArray(apiData)) {
                console.error("Formato de dados da API inesperado. Esperava um array.");
                handleDataLoadError("A resposta da API não continha os dados esperados.");
                return [];
            }
            return apiData.map(item => {
                const findField = (aliases) => aliases.find(alias => item[alias] !== undefined);

                const consultorField = findField(['operador', 'agent_name', 'consultor', 'nome']);
                const tipoField = findField(['descricao', 'pause_type', 'tipo', 'motivo']);
                const dataInicioField = findField(['inicio', 'start_time', 'data_inicio']);
                const duracaoSecondsField = findField(['duration_seconds']);
                const duracaoStringField = findField(['duracao', 'tempo']);

                const consultor = item[consultorField] || 'Não informado';
                const tipo = item[tipoField] || 'Não informado';
                const dataInicio = item[dataInicioField];
                
                let durationMinutes = 0;
                if (item[duracaoSecondsField] !== undefined) {
                    durationMinutes = (item[duracaoSecondsField] || 0) / 60;
                } else if (item[duracaoStringField] !== undefined) {
                    durationMinutes = parseDurationToMinutes(item[duracaoStringField] || '0');
                }

                return {
                    CONSULTOR: normalizeDataString(consultor),
                    TIPO: toTitleCase(normalizeDataString(tipo)),
                    DATA_INICIO_OBJ: parseDateTimeRobust(dataInicio),
                    DURACAO_MINUTES: durationMinutes
                };
            }).filter(item => item.DATA_INICIO_OBJ && item.DURACAO_MINUTES > 0);
        }
        
        async function loadArgusApiData() {
            els.main.fileInput.value = '';
            els.main.fileUploadLabel.textContent = 'Escolher arquivo';
            els.main.fileStatus.textContent = 'Conectando ao servidor proxy...';
            els.main.fileStatus.className = 'text-sm text-blue-400 mt-4 animate-pulse';

            const PROXY_URL = "http://localhost:3000/api/dados-argus";
            const payload = {};
            
            const startDate = els.main.apiControls.startDate.value;
            const endDate = els.main.apiControls.endDate.value;

            if (!startDate || !endDate) {
                return handleDataLoadError("Por favor, selecione um período de data.");
            }
            
            payload.periodoInicial = `${startDate}T00:00:00`;
            payload.periodoFinal = `${endDate}T23:59:59`;

            console.log("Payload enviado para o Proxy:", payload);

            try {
                const response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const responseData = await response.json();

                if (!response.ok) {
                    throw new Error(responseData.descStatus || responseData.error || `Erro do Proxy (${response.status})`);
                }

                if (responseData.codStatus && responseData.codStatus < 1) {
                    throw new Error(responseData.descStatus || "A API Argus retornou um erro.");
                }

                if (!responseData.pausasDetalhadas || !Array.isArray(responseData.pausasDetalhadas)) {
                     throw new Error("Formato de resposta inválido: campo 'pausasDetalhadas' não encontrado.");
                }
                
                originalData = transformArgusData(responseData.pausasDetalhadas);

                if (!originalData || originalData.length === 0) {
                    return handleDataLoadError("A API retornou sucesso, mas nenhum registro de pausa foi encontrado para este filtro.");
                }
                
                const dates = originalData.map(d => d.DATA_INICIO_OBJ);
                els.main.filters.startDate.value = formatDateToYYYYMMDD(new Date(Math.min(...dates)));
                els.main.filters.endDate.value = formatDateToYYYYMMDD(new Date(Math.max(...dates)));

                filteredData = [...originalData];
                populateFilters();
                enableDashboardControls(true);
                const exportBtn = document.getElementById('export-html-btn');
                if (exportBtn) {
                    exportBtn.disabled = false; // Habilitar botão de exportar
                }
                els.main.fileStatus.textContent = `Sucesso! ${originalData.length} registros carregados via API Argus.`;
                els.main.fileStatus.className = 'text-sm text-green-400 mt-4 font-medium';
                updateDashboard();

            } catch (error) {
                let msg = error.message;
                if (msg.includes("Failed to fetch")) {
                    msg = "Não foi possível conectar ao servidor proxy. Verifique se ele está rodando no terminal e tente novamente.";
                }
                handleDataLoadError(msg);
            }
        }

        function handleDataLoadError(msg) {
            console.error(msg);
            els.main.fileStatus.textContent = `Erro: ${msg}`;
            els.main.fileStatus.className = 'text-sm text-red-400 mt-4 font-bold';
            originalData = [];
            filteredData = [];
            enableDashboardControls(false);
            const exportBtnErr = document.getElementById('export-html-btn');
            if (exportBtnErr) {
                exportBtnErr.disabled = true;
            }
            updateDashboard();
        }

        function handleCallTabulationsError(msg) {
            console.error(msg);
            if (els.callTabulations.fileStatus) {
                els.callTabulations.fileStatus.textContent = `Erro: ${msg}`;
                els.callTabulations.fileStatus.className = 'text-sm text-red-400 mt-4 font-bold';
            }
            callTabulationsOriginalData = [];
            callTabulationsFilteredData = [];
            enableDashboardControls(false, 'callTabulations');
            updateCallTabulationsDashboard();
        }

        // --- Lógica do Dashboard ---
        function populateFilters() {
            const consultants = [...new Set(originalData.map(d => d.CONSULTOR))].sort();
            const pauseTypes = [...new Set(originalData.map(d => d.TIPO))].sort();

            const consultantFilter = els.main.filters.consultant;
            consultantFilter.innerHTML = '<option value="">Todos</option>';
            consultants.forEach(c => {
                const option = document.createElement('option');
                option.value = c;
                option.textContent = c;
                consultantFilter.appendChild(option);
            });

            const pauseTypeFilter = els.main.filters.pauseType;
            pauseTypeFilter.innerHTML = '<option value="">Todos</option>';
            pauseTypes.forEach(t => {
                const option = document.createElement('option');
                option.value = t;
                option.textContent = t;
                pauseTypeFilter.appendChild(option);
            });
        }

        function populateCallTabulationFilters() {
            const operators = [...new Set(callTabulationsOriginalData.map(d => d.OPERADOR))].sort();
            const tabulationTypes = [...new Set(callTabulationsOriginalData.map(d => d.TABULADO_COMO))].sort();
            const categories = [...new Set(callTabulationsOriginalData.map(d => d.CATEGORIA_TABULACAO))].sort();

            const operatorFilter = els.callTabulations.filters.operator;
            if (operatorFilter) {
                operatorFilter.innerHTML = '<option value="">Todos</option>';
                operators.forEach(c => {
                    const option = document.createElement('option');
                    option.value = c;
                    option.textContent = c;
                    operatorFilter.appendChild(option);
                });
            }

            const typeFilter = els.callTabulations.filters.type;
            if (typeFilter) {
                typeFilter.innerHTML = '<option value="">Todos</option>';
                tabulationTypes.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t;
                    option.textContent = t;
                    typeFilter.appendChild(option);
                });
            }

            const categoryFilter = els.callTabulations.filters.category;
            if (categoryFilter) {
                categoryFilter.innerHTML = '<option value="">Todas</option>';
                categories.forEach(t => {
                    const option = document.createElement('option');
                    option.value = t;
                    option.textContent = t;
                    categoryFilter.appendChild(option);
                });
            }
        }
        
        function enableDashboardControls(enable, dashboardType = 'pauses') {
            if (dashboardType === 'pauses') {
                Object.values(els.main.filters).forEach(el => {
                    if (el) el.disabled = !enable;
                });
                if (els.main.buttons.clearFilters) {
                    els.main.buttons.clearFilters.disabled = !enable;
                }
                if (!enable) {
                    if (els.main.buttons.generateAi) {
                        els.main.buttons.generateAi.disabled = true;
                    }
                    if (els.main.ai.section) {
                        els.main.ai.section.classList.add('hidden');
                    }
                }
            } else if (dashboardType === 'callTabulations') {
                Object.values(els.callTabulations.filters).forEach(el => {
                    if (el) el.disabled = !enable;
                });
                if (els.callTabulations.buttons.clearFilters) {
                    els.callTabulations.buttons.clearFilters.disabled = !enable;
                }
            }
        }

        function applyFilters() {
            const selConsultant = els.main.filters.consultant ? els.main.filters.consultant.value : '';
            const selType = els.main.filters.pauseType ? els.main.filters.pauseType.value : '';

            let startDate = null, endDate = null;
            if (els.main.filters.startDate && els.main.filters.startDate.value) {
                startDate = new Date(els.main.filters.startDate.value);
                startDate = new Date(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate(), 0,0,0);
            }
            if (els.main.filters.endDate && els.main.filters.endDate.value) {
                endDate = new Date(els.main.filters.endDate.value);
                endDate = new Date(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate(), 23, 59, 59, 999);
            }

            filteredData = originalData.filter(d => {
                const matchConsultant = !selConsultant || d.CONSULTOR === selConsultant;
                const matchType = !selType || d.TIPO === selType;
                let matchDate = true;
                if (startDate) matchDate = matchDate && d.DATA_INICIO_OBJ >= startDate;
                if (endDate) matchDate = matchDate && d.DATA_INICIO_OBJ <= endDate;
                return matchConsultant && matchType && matchDate;
            });

            const contextData = originalData.filter(d => {
                const matchType = !selType || d.TIPO === selType;
                let matchDate = true;
                if (startDate) matchDate = matchDate && d.DATA_INICIO_OBJ >= startDate;
                if (endDate) matchDate = matchDate && d.DATA_INICIO_OBJ <= endDate;
                return matchType && matchDate;
            });

            filteredAveragesForComparison = {};
            const totals = {};
            const counts = {};
            contextData.forEach(d => {
                totals[d.TIPO] = (totals[d.TIPO] || 0) + d.DURACAO_MINUTES;
                counts[d.TIPO] = (counts[d.TIPO] || 0) + 1;
            });
            for (const type in totals) {
                filteredAveragesForComparison[type] = totals[type] / counts[type];
            }

            const canUseAI = filteredData.length > 0;
            if (els.main.buttons.generateAi) {
                els.main.buttons.generateAi.disabled = !canUseAI;
            }

            if (!canUseAI && els.main.ai.section) {
                els.main.ai.section.classList.add('hidden');
            }

            updateDashboard();
        }

        function applyCallTabulationFilters() {
            const selOperator = els.callTabulations.filters.operator ? els.callTabulations.filters.operator.value : '';
            const selType = els.callTabulations.filters.type ? els.callTabulations.filters.type.value : '';
            const selCategory = els.callTabulations.filters.category ? els.callTabulations.filters.category.value : '';

            let startDate = null, endDate = null;
            if (els.callTabulations.filters.startDate && els.callTabulations.filters.startDate.value) {
                startDate = new Date(els.callTabulations.filters.startDate.value);
                startDate = new Date(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate(), 0,0,0);
            }
            if (els.callTabulations.filters.endDate && els.callTabulations.filters.endDate.value) {
                endDate = new Date(els.callTabulations.filters.endDate.value);
                endDate = new Date(endDate.getUTCFullYear(), endDate.getUTCMonth(), endDate.getUTCDate(), 23, 59, 59, 999);
            }

            callTabulationsFilteredData = callTabulationsOriginalData.filter(d => {
                const matchOperator = !selOperator || d.OPERADOR === selOperator;
                const matchType = !selType || d.TABULADO_COMO === selType;
                const matchCategory = !selCategory || d.CATEGORIA_TABULACAO === selCategory;
                let matchDate = true;
                if (startDate) matchDate = matchDate && d.DATA_HORA_TABULACAO_OBJ >= startDate;
                if (endDate) matchDate = matchDate && d.DATA_HORA_TABULACAO_OBJ <= endDate;
                return matchOperator && matchType && matchCategory && matchDate;
            });

            updateCallTabulationsDashboard();
        }

        function updateDashboard() {
            renderKPIs();
            renderCharts();
            if (tabulatorTable) {
                tabulatorTable.setData(filteredData);
            }
        }

        function processCallTabulationsData(csvContent) {
            if (callTabulationsTable) {
                callTabulationsTable.destroy();
            }
            els.callTabulations.fileStatus.className = 'text-sm text-slate-400 mt-4';
            hideIgnoredRowsPopup('pauses'); // Esconde o modal de pausas, se estiver aberto

            if (!csvContent || !csvContent.trim()) {
                return handleCallTabulationsError('Arquivo vazio.');
            }

            if (csvContent.charCodeAt(0) === 0xFEFF) {
                csvContent = csvContent.slice(1);
            }

            const lines = csvContent.trim().split(/\r\n|\n|\r/);
            if (lines.length < 2) {
                return handleCallTabulationsError('Arquivo contém apenas cabeçalho ou está vazio.');
            }

            const delimiter = detectDelimiter(lines[0]);
            if (!delimiter) {
                return handleCallTabulationsError('Não foi possível detectar o separador de colunas.');
            }
            
            let rawHeaders = splitCsvLine(lines[0], delimiter);
            let emptyCellOffset = 0;
            if (rawHeaders.length > 0 && rawHeaders[0].trim() === '') {
                rawHeaders = rawHeaders.slice(1);
                emptyCellOffset = 1;
            }

            console.log('Raw Headers (Tabulações):', rawHeaders);
            const headerMap = mapHeaders(rawHeaders, columnAliasesCallTabulations);

            const requiredHeaders = ['OPERADOR', 'DATA_HORA_TABULACAO', 'TABULADO_COMO'];
            const missingHeaders = requiredHeaders.filter(h => !headerMap[h]);

            if (missingHeaders.length > 0) {
                 const missingNames = missingHeaders.map(k => columnAliasesCallTabulations[k].join(' ou ')).join('; \n');
                 return handleCallTabulationsError(`Colunas não encontradas:\n${missingNames}.`);
            }

            const headerIndexes = {};
            for(const key in headerMap) {
                const rawHeaderIndex = rawHeaders.indexOf(headerMap[key]);
                if (rawHeaderIndex !== -1) {
                    headerIndexes[key] = rawHeaderIndex;
                }
            }
            
            const getColumnValue = (key, values) => {
                if (headerIndexes[key] === undefined) return '';
                return values[headerIndexes[key]] || '';
            };

            let ignoredRowsDetails = [];
            callTabulationsOriginalData = lines.slice(1).map((line, index) => {
                const currentLineNumber = index + 2;
                const values = splitCsvLine(line, delimiter);

                if (values.length !== rawHeaders.length + emptyCellOffset) {
                    ignoredRowsDetails.push({ lineNumber: currentLineNumber, reason: 'Número de colunas diferente do cabeçalho', columnName: 'Linha Completa', columnValue: line.substring(0, 150) + (line.length > 150 ? '...' : '') });
                    return null;
                }
                
                const dateRawValue = getColumnValue('DATA_HORA_TABULACAO', values);
                const dateObj = parseDateTimeRobust(dateRawValue);
                const operadorRawValue = getColumnValue('OPERADOR', values);
                const operador = normalizeDataString(operadorRawValue); // Validado aqui

                if (!dateObj) {
                    ignoredRowsDetails.push({ lineNumber: currentLineNumber, reason: 'Data/Hora de Tabulação inválida', columnName: headerMap.DATA_HORA_TABULACAO, columnValue: dateRawValue });
                    return null;
                }
                if (operador === 'Não informado' || operadorRawValue.trim() === '') {
                    ignoredRowsDetails.push({ lineNumber: currentLineNumber, reason: 'Nome do Operador não informado', columnName: headerMap.OPERADOR, columnValue: operadorRawValue });
                    return null;
                }

                // Mapeia todos os campos do alias
                const rowData = {
                    DATA_HORA_TABULACAO_OBJ: dateObj,
                    OPERADOR: operador // <-- *** CORREÇÃO APLICADA AQUI ***
                };
                
                for (const key in columnAliasesCallTabulations) {
                    // Pula os campos que já processamos manualmente
                    if (key !== 'DATA_HORA_TABULACAO' && key !== 'OPERADOR') { 
                        rowData[key] = normalizeDataString(getColumnValue(key, values));
                    }
                }

                return rowData;

            }).filter(row => row !== null);

            if (callTabulationsOriginalData.length === 0) {
                if (ignoredRowsDetails.length > 0) showIgnoredRowsPopup(ignoredRowsDetails, 'pauses');
                return handleCallTabulationsError('Nenhuma linha de dados válida encontrada.');
            }

            const dates = callTabulationsOriginalData.map(d => d.DATA_HORA_TABULACAO_OBJ);
            if (els.callTabulations.filters.startDate) {
                els.callTabulations.filters.startDate.value = formatDateToYYYYMMDD(new Date(Math.min(...dates)));
            }
            if (els.callTabulations.filters.endDate) {
                els.callTabulations.filters.endDate.value = formatDateToYYYYMMDD(new Date(Math.max(...dates)));
            }

            callTabulationsFilteredData = [...callTabulationsOriginalData];
            
            populateCallTabulationFilters();
            enableDashboardControls(true, 'callTabulations'); 

            let statusMsg = `Sucesso! Carregados ${callTabulationsOriginalData.length} registros de tabulação.`;
            if (ignoredRowsDetails.length > 0) {
                statusMsg += ` (${ignoredRowsDetails.length} linhas ignoradas).`;
                showIgnoredRowsPopup(ignoredRowsDetails, 'pauses');
            }

            els.callTabulations.fileStatus.textContent = statusMsg;
            els.callTabulations.fileStatus.className = 'text-sm text-green-400 mt-4 font-medium';
            
            updateCallTabulationsDashboard();
        }

        function updateCallTabulationsDashboard() {
            renderCallTabulationKPIs();
            renderCallTabulationCharts();
            if (callTabulationsTable) {
                callTabulationsTable.destroy();
            }
            if (els.callTabulations.tableContainer) {
                callTabulationsTable = new Tabulator(els.callTabulations.tableContainer, {
                    data: callTabulationsFilteredData,
                    height: "500px",
                    layout: "fitColumns",
                    tooltips: true,
                    placeholder: "Carregue um arquivo CSV para ver os dados de tabulação.",
                    columns: [
                        { title: "Operador", field: "OPERADOR", headerFilter: "input", width: 160, tooltip: true },
                        { title: "Tabulado Como", field: "TABULADO_COMO", headerFilter: "input", width: 220, tooltip: true },
                        { title: "Categoria", field: "CATEGORIA_TABULACAO", headerFilter: "input", width: 220, tooltip: true },
                        { title: "Data", field: "DATA_HORA_TABULACAO_OBJ", hozAlign: "center", width: 180, formatter: (cell) => formatDateTimeDisplay(cell.getValue()), tooltip: (cell) => formatDateTimeDisplay(cell.getValue()) },
                    ],
                    locale: "pt-br",
                    langs: {
                        "pt-br": {
                            "headerFilters": {
                                "default": "filtrar...",
                            }
                        }
                    }
                });
            }
        }

        // --- Renderização ---
        function renderKPIs() {
            let totalMin = 0;
            const uniqueCons = new Set();
            filteredData.forEach(d => {
                totalMin += d.DURACAO_MINUTES;
                uniqueCons.add(d.CONSULTOR);
            });
            if (els.main.kpis.totalPauses) {
                animateValue(els.main.kpis.totalPauses, parseInt(els.main.kpis.totalPauses.innerText) || 0, filteredData.length, 500);
            }
            if (els.main.kpis.totalDuration) {
                els.main.kpis.totalDuration.textContent = formatMinutesToHHMM(totalMin);
            }
            if (els.main.kpis.uniqueConsultants) {
                animateValue(els.main.kpis.uniqueConsultants, parseInt(els.main.kpis.uniqueConsultants.innerText) || 0, uniqueCons.size, 500);
            }
        }

        function renderCallTabulationKPIs() {
            const total = callTabulationsFilteredData.length;
            const uniqueOps = new Set(callTabulationsFilteredData.map(d => d.OPERADOR)).size;
            const dayKeys = new Set(callTabulationsFilteredData.map(d => {
                const dt = d.DATA_HORA_TABULACAO_OBJ || parseDateTimeRobust(d.DATA_HORA_TABULACAO);
                if (!dt) return null;
                return new Date(dt).toISOString().slice(0, 10);
            }).filter(Boolean));
            const days = dayKeys.size || 1;
            const avgPerDay = total / days;

            if (els.callTabulations.kpis && els.callTabulations.kpis.total) {
                animateValue(els.callTabulations.kpis.total, parseInt(els.callTabulations.kpis.total.innerText) || 0, total, 500);
            }
            if (els.callTabulations.kpis && els.callTabulations.kpis.uniqueOperators) {
                animateValue(els.callTabulations.kpis.uniqueOperators, parseInt(els.callTabulations.kpis.uniqueOperators.innerText) || 0, uniqueOps, 500);
            }
            if (els.callTabulations.kpis && els.callTabulations.kpis.avgPerDay) {
                els.callTabulations.kpis.avgPerDay.textContent = avgPerDay.toFixed(1);
            }
        }

        function animateValue(obj, start, end, duration) {
            if (!obj) return;
            if (start === end) { obj.innerText = end; return; }
            let startTimestamp = null;
            const step = (timestamp) => {
                if (!startTimestamp) startTimestamp = timestamp;
                const progress = Math.min((timestamp - startTimestamp) / duration, 1);
                obj.innerText = Math.floor(progress * (end - start) + start);
                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    obj.innerText = end;
                }
            };
            window.requestAnimationFrame(step);
        }

        function aggregateData(key, dataset) {
            const source = dataset || filteredData;
            const agg = {};
            source.forEach(d => {
                agg[d[key]] = (agg[d[key]] || 0) + d.DURACAO_MINUTES;
            });
            return agg;
        }

        function aggregateTabulationData(key, dataset) {
            const source = dataset || callTabulationsFilteredData;
            const agg = {};
            source.forEach(d => {
                const value = d[key] || 'Não informado';
                agg[value] = (agg[value] || 0) + 1;
            });
            return agg;
        }

        function aggregateAverage(key, dataset) {
            const source = dataset || filteredData;
            const totals = {};
            const counts = {};
            source.forEach(d => {
                totals[d[key]] = (totals[d[key]] || 0) + d.DURACAO_MINUTES;
                counts[d[key]] = (counts[d[key]] || 0) + 1;
            });
            const avgs = {};
            for(const k in totals) avgs[k] = totals[k] / counts[k];
            return avgs;
        }
        
        // Função global: mapeia um rótulo estável para uma cor HSL determinística
        // Usada por múltiplos gráficos (barras e donut) para manter consistência.
        function stableColorForKey(key, sat = 95, light = 45) {
            if (!key) return `hsl(0, ${sat}%, ${light}%)`;
            let hash = 5381;
            for (let i = 0; i < key.length; i++) {
                hash = ((hash << 5) + hash) + key.charCodeAt(i);
            }
            const hue = Math.abs(hash) % 360;
            return `hsl(${hue}, ${sat}%, ${light}%)`;
        }
        
        function createChart(canvasId, chartInstanceVar, type, labels, data, label, color, fullLabels = null, tooltipUnit = 'min', onSelect = null, highlightIndex = null, highlightColor = '#F59E0B') {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            if (charts[chartInstanceVar]) charts[chartInstanceVar].destroy();

            const chartColors = {
                'barDefault': '#2563EB',
            };

            const generateWheelColors = (n) => {
                const count = Math.max(1, n || 0);
                const step = 360 / count;
                const colors = [];
                for (let i = 0; i < count; i++) {
                    const hue = Math.round((i * step) % 360);
                    colors.push(`hsl(${hue}, 95%, 45%)`);
                }
                return colors;
            };

            // Mapeamento de cor estável por rótulo (tipo/operador/categoria)
            // Usa a função global acima para garantir acesso em todos os contextos.

            // Utilitário: converter cor para HSL e torná-la mais "viva"
            const parseColorToHsl = (input) => {
                if (!input) return { h: 210, s: 85, l: 50 };
                const hexMatch = /^#([0-9a-fA-F]{6})$/i.exec(input);
                if (hexMatch) {
                    const hex = hexMatch[1];
                    const r = parseInt(hex.substr(0,2), 16) / 255;
                    const g = parseInt(hex.substr(2,2), 16) / 255;
                    const b = parseInt(hex.substr(4,2), 16) / 255;
                    const max = Math.max(r,g,b), min = Math.min(r,g,b);
                    let h, s, l = (max + min) / 2;
                    if (max === min) { h = 0; s = 0; }
                    else {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                            case g: h = (b - r) / d + 2; break;
                            case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                    }
                    return { h: Math.round(h*360), s: Math.round(s*100), l: Math.round(l*100) };
                }
                const hslMatch = /^hsl\(\s*(\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*\)$/i.exec(input);
                if (hslMatch) {
                    return { h: parseInt(hslMatch[1],10), s: parseInt(hslMatch[2],10), l: parseInt(hslMatch[3],10) };
                }
                // Fallback: azul vivo
                return { h: 210, s: 85, l: 50 };
            };

            const hslToCss = ({h,s,l}) => `hsl(${Math.max(0,Math.min(360,h))}, ${Math.max(0,Math.min(100,s))}%, ${Math.max(0,Math.min(100,l))}%)`;
            const vividifyColor = (color, satBoost = 8, lightBoost = 6) => {
                const hsl = parseColorToHsl(color);
                hsl.s = Math.min(100, hsl.s + satBoost);
                hsl.l = Math.min(100, hsl.l + lightBoost);
                return hslToCss(hsl);
            };

            let backgroundColor;
            const useStableByLabel = (type === 'bar' && (color === 'stableByLabel' || color === 'stable'));
            if (type === 'doughnut' || useStableByLabel) {
                const getLabelForIndex = (idx) => (Array.isArray(fullLabels) ? fullLabels[idx] : labels[idx]);
                backgroundColor = labels.map((_, idx) => stableColorForKey(getLabelForIndex(idx)));
            } else {
                // Para gráficos de barra, não alteramos a cor da barra selecionada aqui.
                // O destaque visual será feito pelo overlay neon.
                // Caso seja necessário mudar cor (ex.: Total por Tipo), passe um array em `color` no call site.
                backgroundColor = Array.isArray(color) ? color : (color || chartColors.barDefault);
            }

            // Altura do canvas é controlada pelo container via CSS; evitar setar inline

            const config = {
                type: type,
                data: {
                    labels: labels,
                    datasets: [{
                        label: label,
                        data: data,
                        backgroundColor: backgroundColor,
                        borderColor: type === 'doughnut' ? '#252532' : 'transparent',
                        borderWidth: type === 'doughnut' ? 1.2 : 1,
                        hoverOffset: type === 'doughnut' ? 8 : 0,
                        // Destacar o slice selecionado com pequeno "pop-out"
                        offset: (type === 'doughnut') ? labels.map((_, idx) => (highlightIndex !== null && idx === highlightIndex) ? 12 : 0) : undefined
                    }]
                },
                // Plugins de efeito de seleção (glow em doughnut, overlay neon em barra)
                plugins: (function(){
                    const arr = [];
                    if (type === 'doughnut') {
                        const selectionGlow = {
                            id: 'selectionGlow',
                            afterDatasetsDraw(chart) {
                                if (highlightIndex === null || highlightIndex < 0) return;
                                try {
                                    const meta = chart.getDatasetMeta(0);
                                    const arc = meta && meta.data && meta.data[highlightIndex];
                                    if (!arc) return;
                                    const ds = chart.data.datasets[0];
                                    let baseColor = Array.isArray(ds.backgroundColor) ? ds.backgroundColor[highlightIndex] : ds.backgroundColor;
                                    const glowColor = vividifyColor(baseColor || '#F59E0B');
                                    const { x, y, startAngle, endAngle, outerRadius } = arc;
                                    const ctx = chart.ctx;
                                    ctx.save();
                                    ctx.globalCompositeOperation = 'lighter';
                                    ctx.strokeStyle = glowColor;
                                    ctx.lineWidth = 10;
                                    ctx.shadowColor = glowColor;
                                    ctx.shadowBlur = 28;
                                    ctx.shadowOffsetX = 0;
                                    ctx.shadowOffsetY = 0;
                                    ctx.beginPath();
                                    ctx.arc(x, y, outerRadius + 6, startAngle, endAngle);
                                    ctx.stroke();
                                    ctx.restore();
                                } catch(e) {}
                            }
                        };
                        arr.push(selectionGlow);
                    }
                    if (type === 'bar') {
                        const barSelectionOverlay = {
                            id: 'barSelectionOverlay',
                            afterDatasetsDraw() {
                                try {
                                    // Aplica overlay sempre após desenhar as barras
                                    // Não aplicar blur no canvas base para não ocultar rótulos do eixo.
                                    // apply function defined below in the type==='bar' block
                                    if (typeof applyBlurHighlight === 'function') {
                                        applyBlurHighlight();
                                    }
                                } catch(e) {}
                            }
                        };
                        arr.push(barSelectionOverlay);
                    }
                    return arr;
                })(),
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 100,
                    interaction: { mode: 'nearest', intersect: true },
                    elements: {
                        bar: { maxBarThickness: 28 }
                    },
                    layout: {
                        padding: { left: 8, right: 8, top: 4, bottom: 8 }
                    },
                    // Melhor proporção para doughnut com legenda inferior
                    cutout: (type === 'doughnut') ? '62%' : undefined,
                    plugins: {
                        legend: {
                            display: type === 'doughnut',
                            position: type === 'doughnut' ? 'bottom' : 'right',
                            labels: { color: '#cbd5e1', font: { size: 11 }, boxWidth: 12, padding: 10 }
                        },
                        tooltip: {
                            enabled: (chartInstanceVar === 'consultantTotal') ? false : true,
                            callbacks: {
                                title: function(tooltipItems) {
                                    if (fullLabels && tooltipItems.length > 0) {
                                        const dataIndex = tooltipItems[0].dataIndex;
                                        return fullLabels[dataIndex];
                                    }
                                    return tooltipItems[0].label;
                                },
                                label: function(context) {
                                    let val = context.raw;
                                    let lbl = (type === 'doughnut') ? context.label : '';
                                    if (lbl) lbl += ': ';
                                    if (type === 'doughnut') {
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const perc = total > 0 ? ((val / total) * 100).toFixed(1) + '%' : '0%';
                                        if (tooltipUnit === 'min') {
                                            return `${lbl}${formatMinutesToHHMM(val)} (${perc})`;
                                        } else {
                                            return `${lbl}${val} (${perc})`;
                                        }
                                    }
                                    if (tooltipUnit === 'min') {
                                        return `Duração: ${formatMinutesToHHMM(val)} (${val.toFixed(1)} min)`;
                                    } else {
                                        return `${label}: ${val}`;
                                    }
                                }
                            },
                            external: function(context) {
                                // Apenas para o gráfico de consultor: renderiza o tooltip como HTML acima do overlay
                                if (chartInstanceVar !== 'consultantTotal') return;
                                const { chart, tooltip } = context;
                                let tooltipEl = chart.canvas.parentNode.querySelector('.chart-tooltip');
                                if (!tooltipEl) {
                                    tooltipEl = document.createElement('div');
                                    tooltipEl.className = 'chart-tooltip';
                                    chart.canvas.parentNode.style.position = 'relative';
                                    chart.canvas.parentNode.appendChild(tooltipEl);
                                }
                                if (tooltip.opacity === 0) {
                                    tooltipEl.style.opacity = '0';
                                    return;
                                }
                                const title = (tooltip.title && tooltip.title.length) ? tooltip.title.join(' ') : '';
                                const body = tooltip.body ? tooltip.body.map(b => b.lines).flat().join('\n') : '';
                                tooltipEl.innerHTML = `<div class="title">${title}</div><div class="body">${body}</div>`;
                                const canvasRect = chart.canvas.getBoundingClientRect();
                                const parentRect = chart.canvas.parentNode.getBoundingClientRect();
                                const left = tooltip.caretX + (canvasRect.left - parentRect.left);
                                const top = tooltip.caretY + (canvasRect.top - parentRect.top);
                                tooltipEl.style.left = left + 'px';
                                tooltipEl.style.top = top + 'px';
                                tooltipEl.style.opacity = '1';
                            }
                        }
                    },
                    scales: (type === 'bar') ? {
                        y: {
                            beginAtZero: true,
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#94a3b8' }
                        },
                        x: {
                            grid: { color: 'transparent' },
                            ticks: { 
                                color: '#94a3b8',
                                // Mostrar todas as legendas e rotacionar para caber melhor
                                autoSkip: false,
                                maxRotation: 60,
                                minRotation: 45,
                                font: { size: 11 },
                                callback: (value, index) => {
                                    // Usar rótulos abreviados no eixo; manter completos apenas no tooltip
                                    return (config.data && config.data.labels) ? config.data.labels[index] : value;
                                }
                            }
                        }
                    } : {},
                    onHover: (evt, elements) => {
                        try { canvas.style.cursor = (onSelect && elements && elements.length > 0) ? 'pointer' : 'default'; } catch(e) {}
                    },
                    onClick: (evt, elements) => {
                        if (!onSelect) return;
                        if (elements && elements.length > 0) {
                            const idx = elements[0].index;
                            onSelect(idx);
                        } else {
                            // Clique em área vazia limpa a seleção
                            onSelect(null);
                        }
                    }
                }
            };

            const chart = new Chart(ctx, config);
            charts[chartInstanceVar] = chart;

            // Correção específica: garantir que o gráfico "Total por Tipo" atualize a cor
            // para coincidir com o donut quando há um tipo selecionado.
            if (chartInstanceVar === 'typeTotal') {
                try {
                    if (dashboardSelection && dashboardSelection.pauseType) {
                        const selected = dashboardSelection.pauseType;
                        const newColors = (labels && labels.length <= 1)
                            ? stableColorForKey(labels[0])
                            : labels.map(lbl => lbl === selected ? stableColorForKey(lbl) : '#22C55E');
                        chart.data.datasets[0].backgroundColor = newColors;
                        chart.update();
                    }
                } catch (e) {}
            }

            // Correção adicional: no gráfico de Consultores, force a atualização
            // das cores para que somente a barra selecionada use a cor de destaque.
            // Não alterar diretamente a cor das barras do gráfico de consultores;
            // o efeito de seleção fica por conta do overlay.

            // Efeito de blur/escurecimento com "neon" para gráficos de barra com seleção ativa
            if (type === 'bar') {
                let overlayCanvas = document.getElementById(`${canvasId}-overlay`);
                const ensureOverlay = () => {
                    if (!overlayCanvas) {
                        overlayCanvas = document.createElement('canvas');
                        overlayCanvas.id = `${canvasId}-overlay`;
                        overlayCanvas.style.position = 'absolute';
                        overlayCanvas.style.top = '0';
                        overlayCanvas.style.left = '0';
                        overlayCanvas.style.pointerEvents = 'none';
                        overlayCanvas.style.zIndex = '2';
                        canvas.style.zIndex = '1';
                        overlayCanvas.style.willChange = 'filter, opacity, transform';
                        canvas.parentElement.style.position = 'relative';
                        canvas.parentElement.appendChild(overlayCanvas);
                    }
                    // Sincroniza tamanho com base em pixels reais do canvas (alta densidade / zoom)
                    overlayCanvas.width = canvas.width;
                    overlayCanvas.height = canvas.height;
                    // Sincroniza dimensões CSS visuais usando o tamanho real exibido
                    const rect = canvas.getBoundingClientRect();
                    overlayCanvas.style.width = `${Math.round(rect.width)}px`;
                    overlayCanvas.style.height = `${Math.round(rect.height)}px`;
                };

                const applyBlurHighlight = () => {
                    ensureOverlay();
                    const octx = overlayCanvas.getContext('2d');
                    octx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    if (highlightIndex !== null && highlightIndex >= 0) {
                        // Garante visibilidade do overlay quando há seleção
                        overlayCanvas.style.display = '';
                        try {
                            const meta = chart.getDatasetMeta(0);
                            const area = chart.chartArea || { left: 0, right: overlayCanvas.width, top: 0, bottom: overlayCanvas.height };
                            const count = (meta && meta.data) ? meta.data.length : 0;
                            if (!count || highlightIndex < 0 || highlightIndex >= count) {
                                overlayCanvas.style.display = 'none';
                                return;
                            }
                            const el = meta.data[highlightIndex];
                            // Geometria via escalas
                            const ds = chart.data.datasets[0];
                            const val = Array.isArray(ds.data) ? ds.data[highlightIndex] : ds.data;
                            const yScale = chart.scales && chart.scales['y'];
                            const xScale = chart.scales && chart.scales['x'];
                            let base = (yScale && typeof yScale.getPixelForValue === 'function') ? yScale.getPixelForValue(0) : area.bottom;
                            let top = (yScale && typeof yScale.getPixelForValue === 'function') ? yScale.getPixelForValue(val) : (el && typeof el.y === 'number' ? el.y : area.top);
                            let height = Math.abs(base - top);
                            top = Math.min(top, base);
                            // Centro X e largura
                            let x = (el && typeof el.x === 'number') 
                                ? el.x 
                                : (xScale && typeof xScale.getPixelForTick === 'function' 
                                    ? xScale.getPixelForTick(highlightIndex) 
                                    : (area.left + area.right) / 2);
                            let width = (el && typeof el.width === 'number' && el.width > 0) 
                                ? el.width 
                                : Math.max(6, (area.right - area.left) / Math.max(1, count) * 0.7);
                            // Aumenta a largura para destacar (efeito "pop")
                            const scaleFactor = 1.12; // 12% mais larga
                            let scaledWidth = width * scaleFactor;
                            let scaledLeft = x - scaledWidth / 2;
                            // Clamps para evitar estouro fora da área do gráfico
                            const clampLeft = Math.max(area.left, scaledLeft);
                            const clampRight = Math.min(area.right, scaledLeft + scaledWidth);
                            const clampWidth = Math.max(0, clampRight - clampLeft);

                            // 1) Escurece apenas a área do gráfico (chartArea), preservando números/eixos fora
                            octx.save();
                            octx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                            octx.fillRect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                            // 2) Recorta (remove) a área da barra selecionada (com largura ampliada) para mantê-la nítida
                            octx.globalCompositeOperation = 'destination-out';
                            octx.fillRect(clampLeft, top, clampWidth, height);
                            octx.restore();

                            // 3) Preenche a barra inteira com efeito "neon" (glow)
                            let selectedColor = chart.data.datasets[0].backgroundColor;
                            if (Array.isArray(selectedColor)) selectedColor = selectedColor[highlightIndex] || highlightColor;
                            const vivid = vividifyColor(selectedColor || highlightColor);

                            // Passo A: preenchimento principal nítido (barra inteira) com leve sombra para "lift"
                            octx.save();
                            // Garante que nada saia da área do gráfico
                            octx.beginPath();
                            octx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                            octx.clip();
                            octx.globalCompositeOperation = 'source-over';
                            octx.fillStyle = vivid;
                            octx.globalAlpha = 0.95;
                            // Sombra para efeito de destaque do fundo
                            octx.shadowColor = 'rgba(0, 0, 0, 0.55)';
                            octx.shadowBlur = 10;
                            octx.shadowOffsetX = 0;
                            octx.shadowOffsetY = 6;
                            octx.fillRect(clampLeft, top, clampWidth, height);
                            octx.restore();

                            // Passo B: brilho ao redor (neon) cobrindo toda a barra
                            octx.save();
                            octx.globalCompositeOperation = 'lighter';
                            octx.fillStyle = vivid;
                            octx.globalAlpha = 0.35;
                            octx.shadowColor = vivid;
                            octx.shadowBlur = 24;
                            octx.shadowOffsetX = 0;
                            octx.shadowOffsetY = 0;
                            octx.fillRect(clampLeft, top, clampWidth, height);
                            octx.restore();
                        } catch (e) {
                            // Em caso de erro de geometria, ocultar overlay para evitar bug visual
                            overlayCanvas.style.display = 'none';
                        }
                    } else {
                        // Sem seleção: limpa overlay e oculta
                        octx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        overlayCanvas.style.display = 'none';
                    }
                };

                // Aplica após layout para garantir que chartArea já existe
                requestAnimationFrame(() => {
                    overlayCanvas && (overlayCanvas.style.display = '');
                    applyBlurHighlight();
                });

                // Reaplica durante animação e após redimensionamentos para evitar falhas de desenho
                try {
                    chart.options.animation = Object.assign({}, chart.options.animation, {
                        duration: (chart.options.animation && chart.options.animation.duration) || 350,
                        onProgress: () => applyBlurHighlight(),
                        onComplete: () => applyBlurHighlight()
                    });
                } catch(e) {}
                // Ajusta em resize
                try {
                    const resizeObserver = new ResizeObserver(() => {
                        ensureOverlay();
                        applyBlurHighlight();
                    });
                    // Observar o próprio canvas para capturar mudanças de tamanho internas (zoom/dpr)
                    resizeObserver.observe(canvas);
                } catch(e) {
                    // Fallback: escuta resize da janela
                    window.addEventListener('resize', () => {
                        ensureOverlay();
                        applyBlurHighlight();
                    });
                }
            }
        }

        function renderCharts() {
            // Dataset do gráfico de consultores: aplica filtro por tipo de pausa (se houver), mas não por consultor
            const consultantChartDataset = filteredData.filter(d => !dashboardSelection.pauseType || d.TIPO === dashboardSelection.pauseType);
            const consData = aggregateData('CONSULTOR', consultantChartDataset);
            const consLabels = Object.keys(consData).sort((a, b) => consData[b] - consData[a]);
            const abbreviatedLabels = consLabels.map(name => abbreviateName(name));
            const selectedIndex = dashboardSelection.consultant ? consLabels.indexOf(dashboardSelection.consultant) : null;
            createChart(
                'total-pause-consultant-chart', 
                'consultantTotal', 
                'bar', 
                abbreviatedLabels,
                consLabels.map(k => consData[k]), 
                'Total Duração', 
                '#1D4ED8',
                consLabels,
                'min',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.consultant = null;
                    } else {
                        const clickedConsultant = consLabels[idx];
                        dashboardSelection.consultant = (dashboardSelection.consultant === clickedConsultant) ? null : clickedConsultant;
                    }
                    // Re-render para aplicar filtro nos demais gráficos
                    renderCharts();
                },
                selectedIndex,
                '#F59E0B'
            );
            // Demais gráficos usam dataset conforme seleção atual de consultor
            const selectionDataset = filteredData.filter(d => {
                const matchConsultant = !dashboardSelection.consultant || d.CONSULTOR === dashboardSelection.consultant;
                const matchPauseType = !dashboardSelection.pauseType || d.TIPO === dashboardSelection.pauseType;
                return matchConsultant && matchPauseType;
            });

            // Para o gráfico "Total por Tipo", não filtramos por tipo
            // para manter todas as barras visíveis e destacar a selecionada.
            const datasetForTypeBars = filteredData.filter(d => {
                const matchConsultantOnly = !dashboardSelection.consultant || d.CONSULTOR === dashboardSelection.consultant;
                return matchConsultantOnly; // ignora filtro por tipo aqui
            });
            const typeData = aggregateData('TIPO', datasetForTypeBars);
            const typeLabels = Object.keys(typeData).sort();
            const selectedTypeIndex = dashboardSelection.pauseType ? typeLabels.indexOf(dashboardSelection.pauseType) : null;
            const barColorForType = (() => {
                if (!dashboardSelection.pauseType) return '#22C55E';
                if (typeLabels.length <= 1) return stableColorForKey(typeLabels[0]);
                // Multi-barras: pinta somente a selecionada com a cor do donut
                return typeLabels.map(lbl => lbl === dashboardSelection.pauseType ? stableColorForKey(lbl) : '#22C55E');
            })();
            createChart(
                'total-pause-type-chart', 
                'typeTotal', 
                'bar', 
                typeLabels, 
                typeLabels.map(k => typeData[k]), 
                'Total Duração', 
                barColorForType, 
                typeLabels, 
                'min',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.pauseType = null;
                    } else {
                        const clickedType = typeLabels[idx];
                        dashboardSelection.pauseType = (dashboardSelection.pauseType === clickedType) ? null : clickedType;
                    }
                    renderCharts();
                },
                selectedTypeIndex,
                '#F59E0B'
            );

            const typeAvgData = aggregateAverage('TIPO', selectionDataset);
            const avgChartData = typeLabels.map(type => typeAvgData[type] || 0);
            createChart(
                'average-pause-type-chart', 
                'typeAverage', 
                'bar', 
                typeLabels, 
                avgChartData, 
                'Média Duração', 
                '#F59E0B', 
                null, 
                'min',
                null,
                selectedTypeIndex,
                '#F59E0B'
            );

            createChart(
                'pause-type-distribution-chart', 
                'typeDistribution', 
                'doughnut', 
                typeLabels, 
                typeLabels.map(k => typeData[k]), 
                'Distribuição', 
                null, 
                null, 
                'min',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.pauseType = null;
                    } else {
                        const clickedType = typeLabels[idx];
                        dashboardSelection.pauseType = (dashboardSelection.pauseType === clickedType) ? null : clickedType;
                    }
                    renderCharts();
                },
                selectedTypeIndex,
                '#F59E0B'
            );
        }

        function renderCallTabulationCharts() {
            // Aplica seleção global
            const selectionTabDataset = callTabulationsFilteredData.filter(d => {
                const matchOperator = !dashboardSelection.tabOperator || d.OPERADOR === dashboardSelection.tabOperator;
                const matchType = !dashboardSelection.tabType || d.TABULADO_COMO === dashboardSelection.tabType;
                const matchCategory = !dashboardSelection.tabCategory || d.CATEGORIA_TABULACAO === dashboardSelection.tabCategory;
                return matchOperator && matchType && matchCategory;
            });

            const operatorData = aggregateTabulationData('OPERADOR', selectionTabDataset);
            const operatorLabels = Object.keys(operatorData).sort((a, b) => operatorData[b] - operatorData[a]);
            const abbreviatedOperatorLabels = operatorLabels.map(name => abbreviateName(name));
            const selectedOperatorIndex = dashboardSelection.tabOperator ? operatorLabels.indexOf(dashboardSelection.tabOperator) : null;
            createChart(
                'total-tabulations-operator-chart',
                'tabulationOperatorTotal',
                'bar',
                abbreviatedOperatorLabels,
                operatorLabels.map(k => operatorData[k]),
                'Total de Tabulações',
                '#7C3AED',
                operatorLabels,
                'count',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.tabOperator = null;
                    } else {
                        const clickedOperator = operatorLabels[idx];
                        dashboardSelection.tabOperator = (dashboardSelection.tabOperator === clickedOperator) ? null : clickedOperator;
                    }
                    renderCallTabulationCharts();
                },
                selectedOperatorIndex,
                '#F59E0B'
            );

            const typeData = aggregateTabulationData('TABULADO_COMO', selectionTabDataset);
            const typeLabels = Object.keys(typeData).sort();
            const abbreviatedTypeLabelsForLegend = typeLabels.map(lbl => abbreviateLabel(lbl));
            const selectedTypeIndex = dashboardSelection.tabType ? typeLabels.indexOf(dashboardSelection.tabType) : null;
            createChart(
                'total-tabulations-type-chart',
                'tabulationTypeTotal',
                'bar',
                typeLabels,
                typeLabels.map(k => typeData[k]),
                'Total de Tabulações',
                '#22C55E',
                null,
                'count',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.tabType = null;
                    } else {
                        const clickedType = typeLabels[idx];
                        dashboardSelection.tabType = (dashboardSelection.tabType === clickedType) ? null : clickedType;
                    }
                    renderCallTabulationCharts();
                },
                selectedTypeIndex,
                '#F59E0B'
            );

            const categoryData = aggregateTabulationData('CATEGORIA_TABULACAO', selectionTabDataset);
            const categoryLabels = Object.keys(categoryData).sort();
            const selectedCategoryIndex = dashboardSelection.tabCategory ? categoryLabels.indexOf(dashboardSelection.tabCategory) : null;
            createChart(
                'total-tabulations-category-chart',
                'tabulationCategoryTotal',
                'bar',
                categoryLabels,
                categoryLabels.map(k => categoryData[k]),
                'Total de Tabulações',
                '#F59E0B',
                null,
                'count',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.tabCategory = null;
                    } else {
                        const clickedCategory = categoryLabels[idx];
                        dashboardSelection.tabCategory = (dashboardSelection.tabCategory === clickedCategory) ? null : clickedCategory;
                    }
                    renderCallTabulationCharts();
                },
                selectedCategoryIndex,
                '#F59E0B'
            );

            createChart(
                'tabulation-type-distribution-chart',
                'tabulationTypeDistribution',
                'doughnut',
                abbreviatedTypeLabelsForLegend,
                typeLabels.map(k => typeData[k]),
                'Distribuição de Tabulações',
                null,
                typeLabels,
                'count',
                (idx) => {
                    if (idx === null) {
                        dashboardSelection.tabType = null;
                    } else {
                        const clickedType = typeLabels[idx];
                        dashboardSelection.tabType = (dashboardSelection.tabType === clickedType) ? null : clickedType;
                    }
                    renderCallTabulationCharts();
                },
                selectedTypeIndex,
                '#F59E0B'
            );
        }

        // --- Integração IA (Gemini) ---
        async function generateAIAnalysis() {
            const isPauses = !els.main.pausesDashboardContent.classList.contains('hidden');
            const pausesData = filteredData;
            const tabData = callTabulationsFilteredData;

            if (els.main.ai.section) {
                els.main.ai.section.classList.remove('hidden');
            }
            if (els.main.ai.placeholder) {
                els.main.ai.placeholder.classList.add('hidden');
            }
            if (els.main.ai.loading) {
                els.main.ai.loading.classList.remove('hidden');
            }
            if (els.main.ai.content) {
                els.main.ai.content.innerHTML = '';
            }
            if (els.main.ai.section) {
                els.main.ai.section.scrollIntoView({ behavior: 'smooth' });
            }

            let prompt = '';
            if (isPauses) {
                const totalPausas = pausesData.length;
                const totalMinutos = pausesData.reduce((sum, d) => sum + d.DURACAO_MINUTES, 0);
                const uniqueConsultants = [...new Set(pausesData.map(d => d.CONSULTOR))];

                const typeStats = {};
                pausesData.forEach(d => {
                    if(!typeStats[d.TIPO]) typeStats[d.TIPO] = { total: 0, count: 0 };
                    typeStats[d.TIPO].total += d.DURACAO_MINUTES;
                    typeStats[d.TIPO].count++;
                });

                let dataText = `Período: ${els.main.filters.startDate.value} a ${els.main.filters.endDate.value}\nConsultores ativos: ${uniqueConsultants.length}\nTotal Pausas: ${totalPausas}, Tempo Total: ${formatMinutesToHHMM(totalMinutos)}\n\nDetalhamento por Tipo:\n`;
                for(const type in typeStats) {
                    const stats = typeStats[type];
                    const avg = stats.total / stats.count;
                    const contextAvg = filteredAveragesForComparison[type] || 0;
                    let statusDescription = '';
                    const expected = expectedDurations[type];
                    if (expected) {
                        const lowerBound = expected.minutes - expected.tolerance;
                        const upperBound = expected.minutes + expected.tolerance;
                        if (avg >= lowerBound && avg <= upperBound) statusDescription = `(ideal: ${expected.minutes}min - média OK)`;
                        else if (avg < lowerBound) statusDescription = `(ideal: ${expected.minutes}min - média curta)`;
                        else statusDescription = `(ideal: ${expected.minutes}min - média longa)`;
                    } else {
                        const diffPerc = contextAvg > 0 ? ((avg - contextAvg) / contextAvg) * 100 : 0;
                        if (diffPerc > 10) statusDescription = `(Equipe: ${contextAvg.toFixed(1)}min, ACIMA +${diffPerc.toFixed(0)}%)`;
                        else if (diffPerc < -10) statusDescription = `(Equipe: ${contextAvg.toFixed(1)}min, ABAIXO ${diffPerc.toFixed(0)}%)`;
                        else statusDescription = `(Equipe: ${contextAvg.toFixed(1)}min, na média)`;
                    }
                    dataText += `- ${type}: ${stats.count}x, Total: ${formatMinutesToHHMM(stats.total)}, Média: ${avg.toFixed(1)}min ${statusDescription}.\n`;
                }

                // Se um único consultor estiver filtrado, foque nele; caso contrário, análise geral
                const selConsult = els.main.filters.consultant ? els.main.filters.consultant.value : '';
                const focusText = selConsult ? `Consultor focado: ${selConsult}\n` : '';
                prompt = `
                    Aja como um analista de performance sênior de call center. Analise os dados de pausas abaixo.
                    Regras operacionais padrão (referências):
                    - Almoço: 60 min; Café/Intervalo: 15 min; Banheiro: 10 min; Negociação: 15 min; Cadastrando Proposta: 10 min.
                    Use a média da equipe como referência para tipos não listados.
                    ${focusText}Dados:\n${dataText}\n
                    Instruções:
                    1. Crie um resumo executivo curto (máx 3 linhas) sobre pausas no período.
                    2. Destaque 1 ponto positivo e 1 ponto de atenção principal.
                    3. Dê 2 sugestões práticas para gestão do time (ou do consultor selecionado).
                    Use formatação Markdown (negrito). Seja conciso.
                `;
            } else {
                // Tabulações
                const totalTabs = tabData.length;
                const uniqueOps = [...new Set(tabData.map(d => d.OPERADOR))].length;
                const typeAgg = {};
                const catAgg = {};
                tabData.forEach(d => {
                    const t = d.TABULADO_COMO || 'Não informado';
                    const c = d.CATEGORIA_TABULACAO || 'Não informado';
                    typeAgg[t] = (typeAgg[t] || 0) + 1;
                    catAgg[c] = (catAgg[c] || 0) + 1;
                });
                let dataText = `Período: ${els.callTabulations.filters.startDate.value} a ${els.callTabulations.filters.endDate.value}\nOperadores ativos: ${uniqueOps}\nTotal de Tabulações: ${totalTabs}\n\nPor Tipo:\n`;
                Object.keys(typeAgg).sort().forEach(t => { dataText += `- ${t}: ${typeAgg[t]}\n`; });
                dataText += `\nPor Categoria:\n`;
                Object.keys(catAgg).sort().forEach(c => { dataText += `- ${c}: ${catAgg[c]}\n`; });

                prompt = `
                    Aja como um analista de qualidade de atendimento. Analise as tabulações (distribuição por tipo/categoria e operadores) e destaque padrões relevantes.
                    Dados:\n${dataText}\n
                    Instruções:
                    1. Dê um resumo executivo (máx 3 linhas) do comportamento das tabulações.
                    2. Aponte 1 insight positivo e 1 ponto de atenção.
                    3. Sugira 2 ações para melhorar qualidade/consistência das tabulações.
                    Use Markdown com negrito para destaques. Seja objetivo.
                `;
            }

            try {
                if (!window.geminiApiKey) {
                    const response = await fetch('/api/gemini-key');
                    if (!response.ok) {
                        const errorText = await response.text();
                        let errorJson = {};
                        try { errorJson = JSON.parse(errorText); } catch {}
                        throw new Error(errorJson.error || `Falha ao obter a chave da API Gemini do servidor. (${response.status})`);
                    }
                    const keyText = await response.text();
                    let keyJson = {};
                    try { keyJson = JSON.parse(keyText); } catch {
                        throw new Error('Resposta inválida do servidor de chave (não-JSON).');
                    }
                    window.geminiApiKey = keyJson.apiKey;
                }
                const modelsToTry = ['gemini-1.5-flash-latest', 'gemini-1.5-pro-latest', 'gemini-1.5-flash'];
                let aiText = '';
                let lastError = null;
                for (const model of modelsToTry) {
                    try {
                        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${window.geminiApiKey}`;
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                        });
                        const respText = await response.text();
                        if (!response.ok) {
                            let errorJson = {};
                            try { errorJson = JSON.parse(respText); } catch {}
                            const msg = errorJson.error?.message || `Erro API IA (${model}): ${response.status} (${respText.slice(0,120)})`;
                            throw new Error(msg);
                        }
                        let dataObj = null;
                        try { dataObj = JSON.parse(respText); } catch {
                            throw new Error(`Resposta não-JSON do modelo (${model}). Trecho: ${respText.slice(0,120)}`);
                        }
                        aiText = dataObj.candidates?.[0]?.content?.parts?.[0]?.text || '';
                        if (aiText) {
                            break;
                        } else {
                            lastError = new Error('Resposta da IA vazia ou malformada.');
                        }
                    } catch (err) {
                        lastError = err;
                        // tenta próximo modelo
                    }
                }
                if (!aiText) throw lastError || new Error('Falha ao gerar análise. Modelos indisponíveis.');
                const htmlText = aiText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                if (els.main.ai.content) {
                    els.main.ai.content.innerHTML = `<div class="prose prose-invert max-w-none">${htmlText}</div>`;
                }
            } catch (error) {
                console.error(error);
                if (els.main.ai.content) {
                    els.main.ai.content.innerHTML = `<p class="text-red-400 font-medium">Falha ao gerar análise. (${error.message})</p>`;
                }
            } finally {
                if (els.main.ai.loading) {
                    els.main.ai.loading.classList.add('hidden');
                }
            }
        }

        // --- Funções do Modal de Erros ---
        function showIgnoredRowsPopup(errors, dashboardType = 'pauses') {
            let modal, overlay, countEl, listEl;

            if (dashboardType === 'pauses') {
                modal = els.main.ignoredRowsModal.modal;
                overlay = els.main.ignoredRowsModal.overlay;
                countEl = els.main.ignoredRowsModal.count;
                listEl = els.main.ignoredRowsModal.list;
            } 
            // Adicionar lógica para 'callTabulations' quando o modal for implementado no HTML

            if (modal && overlay && countEl && listEl) {
                countEl.textContent = errors.length;
                listEl.innerHTML = '';
                errors.slice(0, 100).forEach(err => { // Limita a 100 para não travar o navegador
                    const li = document.createElement('li');
                    li.className = 'error-item';
                    li.innerHTML = `<p><strong>Linha ${err.lineNumber}:</strong> ${err.reason}</p><p>Campo: <span>${err.columnName || 'N/A'}</span>, Valor: <span>"${err.columnValue || 'Vazio'}"</span></p>`;
                    listEl.appendChild(li);
                });
                overlay.classList.remove('hidden');
            }
        }

        function hideIgnoredRowsPopup(dashboardType = 'pauses') {
            let overlay;
            if (dashboardType === 'pauses') {
                overlay = els.main.ignoredRowsModal.overlay;
            }
            // Adicionar lógica para 'callTabulations'

            if (overlay) {
                overlay.classList.add('hidden');
            }
        }

        // --- Função para controlar a Sidebar ---
        function setupSidebar() {
            const toggleBtn = document.getElementById('sidebar-toggle-btn');
            const overlay = document.getElementById('sidebar-overlay');
            const collapseBtn = document.getElementById('sidebar-collapse-btn');
            const body = document.body;

            const updateCollapseBtnUI = () => {
                if (!collapseBtn) return;
                const isCollapsed = body.classList.contains('sidebar-collapsed');
                // Atualiza título e ícone conforme estado
                collapseBtn.title = isCollapsed ? 'Expandir' : 'Recolher';
                const svg = collapseBtn.querySelector('svg path');
                if (svg) {
                    // Chevron right para Expandir; Chevron left para Recolher
                    svg.setAttribute('d', isCollapsed ? 'M9 5l7 7-7 7' : 'M15 19l-7-7 7-7');
                }
            };

            const toggleSidebar = () => {
                body.classList.toggle('sidebar-open');
            };

            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleSidebar);
            }
            if (overlay) {
                overlay.addEventListener('click', toggleSidebar);
            }

            // Alterna modo colapsado (visual com ícones)
            if (collapseBtn) {
                collapseBtn.addEventListener('click', () => {
                    body.classList.toggle('sidebar-collapsed');
                    updateCollapseBtnUI();
                });
                // Inicializa ícone/posição correta ao carregar
                updateCollapseBtnUI();
            }

            const setActiveMenuById = (id) => {
                const items = document.querySelectorAll('#sidebar .menu-item');
                items.forEach(i => i.classList.remove('active'));
                const el = document.getElementById(id);
                if (el) el.classList.add('active');
            };

            const mup = document.getElementById('menu-upload-pauses-btn');
            if (mup) mup.addEventListener('click', () => { if (els && els.main && els.main.fileInput) els.main.fileInput.click(); setActiveMenuById('menu-upload-pauses-btn'); });

            const mut = document.getElementById('menu-upload-tabs-btn');
            if (mut) mut.addEventListener('click', () => { if (els && els.callTabulations && els.callTabulations.fileInput) els.callTabulations.fileInput.click(); setActiveMenuById('menu-upload-tabs-btn'); });
        }

        // --- Função para controlar a Sidebar Recolhível ---
        function setupCollapsibleSidebar() {
            const headers = document.querySelectorAll('#sidebar .collapsible-header');

            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const icon = header.querySelector('.chevron-icon');

                    // Fecha outros painéis abertos para funcionar como um accordion
                    headers.forEach(otherHeader => {
                        const otherContent = otherHeader.nextElementSibling;
                        if (otherContent !== content && !otherContent.classList.contains('collapsed')) {
                            otherContent.classList.add('collapsed');
                            otherHeader.querySelector('.chevron-icon').classList.remove('rotated');
                        }
                    });

                    // Abre ou fecha o painel clicado
                    content.classList.toggle('collapsed');
                    icon.classList.toggle('rotated');
                });

                // Inicia com todos os painéis fechados
                header.nextElementSibling.classList.add('collapsed');
            });
        }

        // --- Janela Flutuante de Filtros ---
        function setupFloatingFiltersPanel() {
            const overlay = document.getElementById('filters-float-overlay');
            const panel = document.getElementById('filters-float-panel');
            const content = document.getElementById('filters-float-content');
            const closeBtn = document.getElementById('filters-float-close-btn');
            const minimizeBtn = document.getElementById('filters-float-minimize-btn');
            const filterBtn = document.getElementById('sidebar-filter-btn');
            const floatingFilterBtn = document.getElementById('floating-filter-btn');
            const resizer = panel.querySelector('.floating-resizer');
            const header = panel.querySelector('.floating-header');

            let currentCard = null;
            let placeholder = null;

            function showPanelForCurrentTab() {
                const isPauses = !els.main.pausesDashboardContent.classList.contains('hidden');
                const card = document.getElementById(isPauses ? 'pauses-filters-card' : 'tabulations-filters-card');
                if (!card || !content) return;
                // cria um marcador para restaurar posição
                placeholder = document.createElement('div');
                placeholder.style.display = 'none';
                card.parentNode.insertBefore(placeholder, card);
                content.appendChild(card);
                currentCard = card;
                panel.style.display = 'block';
                panel.classList.remove('minimized');
            }

            function closePanel() {
                if (currentCard && placeholder) {
                    placeholder.parentNode.insertBefore(currentCard, placeholder);
                    placeholder.remove();
                    placeholder = null;
                    currentCard = null;
                }
                panel.style.display = 'none';
            }

            // Drag behavior
            (function enableDrag() {
                let isDragging = false;
                let startX = 0, startY = 0;
                let panelX = 0, panelY = 0;
                header.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = panel.getBoundingClientRect();
                    panelX = rect.left;
                    panelY = rect.top;
                    document.body.style.userSelect = 'none';
                });
                window.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    panel.style.left = Math.max(0, panelX + dx) + 'px';
                    panel.style.top = Math.max(0, panelY + dy) + 'px';
                });
                window.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        document.body.style.userSelect = '';
                    }
                });
            })();

            // Resize behavior
            (function enableResize() {
                let isResizing = false;
                let startX = 0, startY = 0;
                let startW = 0, startH = 0;
                resizer.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    const rect = panel.getBoundingClientRect();
                    startW = rect.width;
                    startH = rect.height;
                    e.preventDefault();
                    e.stopPropagation();
                });
                window.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    const newW = Math.max(360, startW + dx);
                    const newH = Math.max(280, startH + dy);
                    panel.style.width = newW + 'px';
                    panel.style.height = newH + 'px';
                });
                window.addEventListener('mouseup', () => { isResizing = false; });
            })();

            // Wire buttons (sem overlay; toggle abre/fecha)
            const togglePanel = () => {
                if (panel.style.display === 'block') { closePanel(); } else { showPanelForCurrentTab(); }
            };
            if (filterBtn) { filterBtn.addEventListener('click', togglePanel); }
            if (floatingFilterBtn) { floatingFilterBtn.addEventListener('click', togglePanel); }
            if (closeBtn) { closeBtn.addEventListener('click', closePanel); }
            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', () => {
                    if (panel.style.display !== 'block') { showPanelForCurrentTab(); }
                    const willMinimize = !panel.classList.contains('minimized');
                    if (willMinimize) {
                        // Guardar dimensões atuais definidas inline (por resize) e limpar para deixar o CSS da classe agir
                        panel.dataset.prevWidth = panel.style.width || '';
                        panel.dataset.prevHeight = panel.style.height || '';
                        panel.classList.add('minimized');
                        panel.style.width = '';
                        panel.style.height = '';
                    } else {
                        // Restaurar dimensões anteriores ao minimizar
                        panel.classList.remove('minimized');
                        if (panel.dataset.prevWidth) { panel.style.width = panel.dataset.prevWidth; } else { panel.style.width = ''; }
                        if (panel.dataset.prevHeight) { panel.style.height = panel.dataset.prevHeight; } else { panel.style.height = ''; }
                    }
                });
            }
        }

        // --- Menu Rápido Flutuante ---
        function setupQuickMenu() {
            const menu = document.getElementById('quick-menu');
            const mainBtn = document.getElementById('quick-main-btn');
            const mainIcon = document.getElementById('quick-main-icon');
            const filterBtn = document.getElementById('quick-filter-btn');
            const reportBtn = document.getElementById('quick-report-btn');
            const aiBtn = document.getElementById('quick-ai-btn');
            const legacyFilterBtn = document.getElementById('floating-filter-btn');
            const legacyAiBtn = document.getElementById('floating-ai-btn');

            if (!menu || !mainBtn) return;

            function setIcon(open) {
                if (!mainIcon) return;
                mainIcon.innerHTML = open
                    ? '<path d="M5 5l14 14M19 5L5 19"/>'
                    : '<path d="M12 5v14M5 12h14"/>';
            }

            mainBtn.addEventListener('click', () => {
                const isOpen = menu.classList.toggle('open');
                setIcon(isOpen);
            });

            if (filterBtn) {
                filterBtn.addEventListener('click', () => {
                    // Reusa o handler original do botão de filtros
                    if (legacyFilterBtn) legacyFilterBtn.click();
                });
            }

            if (reportBtn) {
                reportBtn.addEventListener('click', () => {
                    // Gera/baixa o relatório de pausas em HTML, se disponível
                    if (typeof exportarDadosParaHtml === 'function') {
                        exportarDadosParaHtml();
                    } else {
                        // Como fallback, garante que o dashboard de Pausas está visível
                        if (typeof showDashboard === 'function') {
                            showDashboard('pauses');
                        }
                    }
                });
            }

            if (aiBtn) {
                aiBtn.addEventListener('click', () => {
                    // Chama a função existente de análise IA
                    if (typeof generateAIAnalysis === 'function') {
                        generateAIAnalysis();
                    } else if (legacyAiBtn) {
                        legacyAiBtn.click();
                    }
                });
            }
        }
        
        function showDashboard(dashboardType) {
            const isPauses = dashboardType === 'pauses';

            // Botões de Tab
            if (els.main.tabPausasBtn) {
                els.main.tabPausasBtn.classList.toggle('active', isPauses);
            }
            if (els.main.tabCallTabulationsBtn) {
                els.main.tabCallTabulationsBtn.classList.toggle('active', !isPauses);
            }
            
            // Conteúdo do Dashboard Principal
            if (els.main.pausesDashboardContent) {
                els.main.pausesDashboardContent.classList.toggle('hidden', !isPauses);
            }
            if (els.callTabulations.dashboardContent) {
                els.callTabulations.dashboardContent.classList.toggle('hidden', isPauses);
            }

            // Conteúdo da Sidebar
            const pausesSidebar = document.getElementById('pauses-sidebar-content');
            const tabulationsSidebar = document.getElementById('tabulations-sidebar-content');
            if (pausesSidebar) {
                pausesSidebar.classList.toggle('hidden', !isPauses);
            }
            if (tabulationsSidebar) {
                tabulationsSidebar.classList.toggle('hidden', isPauses);
            }
        }

        // --- Inicialização e Event Listeners ---
        function init() {
            setupSidebar();
            setupCollapsibleSidebar();
            setupFloatingFiltersPanel();
            setupQuickMenu();

            // Inicializa a tabela de pausas
            tabulatorTable = new Tabulator("#pause-detail-table", {
                height: "500px",
                layout: "fitData",
                placeholder: "<span class='text-slate-400'>Nenhum dado para exibir. Carregue um arquivo CSV ou use a API.</span>",
                columns: [
                    { title: "Consultor", field: "CONSULTOR", headerFilter: "input", width: 150 },
                    { title: "Tipo de Pausa", field: "TIPO", headerFilter: "input" },
                    { title: "Data Início", field: "DATA_INICIO_OBJ", hozAlign: "center", width: 180, formatter: (cell) => formatDateTimeDisplay(cell.getValue()) },
                    { title: "Duração (HH:MM:SS)", field: "DURACAO_MINUTES", hozAlign: "center", formatter: (cell) => formatMinutesToHHMMSS(cell.getValue()) },
                    { title: "Duração (Min)", field: "DURACAO_MINUTES", hozAlign: "right", formatter: (c) => c.getValue().toFixed(1) },
                    { title: "Meta / Média (Min)", field: "TIPO", hozAlign: "right", formatter: (cell) => {
                        const type = cell.getValue();
                        const expected = expectedDurations[type];
                        if (expected) return expected.minutes.toFixed(1);
                        const avg = filteredAveragesForComparison[type] || 0;
                        return avg.toFixed(1);
                    }},
                    { title: "Status", field: "DURACAO_MINUTES", hozAlign: "center", formatter: (cell) => {
                        const duration = cell.getValue();
                        const type = cell.getRow().getData().TIPO;
                        const expected = expectedDurations[type];
                        let statusText = '';

                        if (expected) {
                            const lowerBound = expected.minutes - expected.tolerance;
                            const upperBound = expected.minutes + expected.tolerance;
                            if (duration >= lowerBound && duration <= upperBound) {
                                statusText = '<span class="status-success font-medium">✓ Correto</span>';
                            } else if (duration < lowerBound) {
                                statusText = '<span class="status-warning font-semibold">↓ Curto</span>';
                            } else {
                                statusText = '<span class="status-danger font-semibold">↑ Longo</span>';
                            }
                        } else {
                            const avg = filteredAveragesForComparison[type] || 0;
                            const isAbove = duration > (avg * 1.1) && avg > 0;
                            statusText = isAbove
                                ? '<span class="status-danger font-semibold">↑ Acima</span>'
                                : '<span class="status-success font-medium">✓ Normal</span>';
                        }
                        return statusText;
                    }}
                ],
                locale: "pt-br",
                langs:{
                    "pt-br":{
                        "headerFilters":{
                            "default":"filtrar...",
                        }
                    }
                }
            });

            // Event listeners para o dashboard de Pausas
            if (els.main.fileInput) {
                els.main.fileInput.addEventListener('change', (e) => {
                    hideIgnoredRowsPopup('pauses');
                    const file = e.target.files[0];
                    if (!file) {
                        if (els.main.fileUploadLabel) {
                            els.main.fileUploadLabel.textContent = 'Escolher arquivo';
                        }
                        return;
                    }
                    if (els.main.fileUploadLabel) {
                        els.main.fileUploadLabel.textContent = file.name;
                    }
                    if (els.main.fileStatus) {
                        els.main.fileStatus.textContent = `Lendo "${file.name}"...`;
                        els.main.fileStatus.className = 'text-sm text-blue-400 mt-4 animate-pulse';
                    }
                    const reader = new FileReader();
                    reader.onload = (evt) => processData(evt.target.result);
                    reader.onerror = () => handleDataLoadError('Falha ao ler o arquivo.');
                    reader.readAsText(file, 'UTF-8');
                });
            }

            if (els.main.buttons.loadArgusApi) {
                els.main.buttons.loadArgusApi.addEventListener('click', loadArgusApiData);
            }
            
            if (els.main.buttons.clearFilters) {
                els.main.buttons.clearFilters.addEventListener('click', () => {
                    if (originalData.length > 0) {
                        const dates = originalData.map(d => d.DATA_INICIO_OBJ);
                        if (els.main.filters.startDate) {
                            els.main.filters.startDate.value = formatDateToYYYYMMDD(new Date(Math.min(...dates)));
                        }
                        if (els.main.filters.endDate) {
                            els.main.filters.endDate.value = formatDateToYYYYMMDD(new Date(Math.max(...dates)));
                        }
                    }
                    if (els.main.filters.consultant) {
                        els.main.filters.consultant.value = '';
                    }
                    if (els.main.filters.pauseType) {
                        els.main.filters.pauseType.value = '';
                    }
                    applyFilters();
                });
            }

            const debouncedApplyFilters = debounce(applyFilters, 300);
            if (els.main.filters) {
                Object.values(els.main.filters).forEach(el => {
                    if (el) {
                        el.addEventListener('change', debouncedApplyFilters);
                    }
                });
            }

            // Event listeners para o dashboard de Tabulações
            if (els.callTabulations.fileInput) {
                els.callTabulations.fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) {
                        els.callTabulations.fileUploadLabel.textContent = 'Escolher arquivo';
                        return;
                    }
                    els.callTabulations.fileUploadLabel.textContent = file.name;
                    els.callTabulations.fileStatus.textContent = `Lendo "${file.name}"...`;
                    els.callTabulations.fileStatus.className = 'text-sm text-blue-400 mt-4 animate-pulse';
                    const reader = new FileReader();
                    reader.onload = (evt) => processCallTabulationsData(evt.target.result);
                    reader.onerror = () => handleCallTabulationsError('Falha ao ler o arquivo de tabulações.');
                    reader.readAsText(file, 'UTF-8');
                });
            }

            const debouncedApplyCallTabulationFilters = debounce(applyCallTabulationFilters, 300);
            if (els.callTabulations.filters) {
                Object.values(els.callTabulations.filters).forEach(filter => {
                    if (filter) {
                        filter.addEventListener('change', debouncedApplyCallTabulationFilters);
                    }
                });
            }

            if (els.callTabulations.buttons.clearFilters) {
                els.callTabulations.buttons.clearFilters.addEventListener('click', () => {
                    if (callTabulationsOriginalData.length > 0) {
                        const dates = callTabulationsOriginalData.map(d => d.DATA_HORA_TABULACAO_OBJ);
                        els.callTabulations.filters.startDate.value = formatDateToYYYYMMDD(new Date(Math.min(...dates)));
                        els.callTabulations.filters.endDate.value = formatDateToYYYYMMDD(new Date(Math.max(...dates)));
                    }
                    els.callTabulations.filters.operator.value = '';
                    els.callTabulations.filters.type.value = '';
                    els.callTabulations.filters.category.value = '';
                    applyCallTabulationFilters();
                });
            }

            // Navegação entre Tabs
            if (els.main.tabPausasBtn) {
                els.main.tabPausasBtn.addEventListener('click', () => showDashboard('pauses'));
            }
            if (els.main.tabCallTabulationsBtn) {
                els.main.tabCallTabulationsBtn.addEventListener('click', () => showDashboard('call-tabulations'));
            }

            // Outros botões e modais
            if (els.main.buttons.generateAi) {
                els.main.buttons.generateAi.addEventListener('click', generateAIAnalysis);
            }
            const floatingAiBtn = document.getElementById('floating-ai-btn');
            if (floatingAiBtn) {
                floatingAiBtn.addEventListener('click', generateAIAnalysis);
            }
            if (els.main.buttons.closeAi) {
                els.main.buttons.closeAi.addEventListener('click', () => {
                    els.main.ai.section.classList.add('hidden');
                    els.main.ai.placeholder.classList.remove('hidden');
                    els.main.ai.content.innerHTML = '';
                });
            }
            
            if (els.main.ignoredRowsModal.closeBtn) {
                els.main.ignoredRowsModal.closeBtn.addEventListener('click', () => hideIgnoredRowsPopup('pauses'));
            }
            if (els.main.ignoredRowsModal.overlay) {
                els.main.ignoredRowsModal.overlay.addEventListener('click', (e) => {
                    if (e.target === els.main.ignoredRowsModal.overlay) {
                        hideIgnoredRowsPopup('pauses');
                    }
                });
            }

            enableDashboardControls(false, 'pauses');
            enableDashboardControls(false, 'callTabulations');

            const today = new Date();
            if (els.main.apiControls.startDate) {
                els.main.apiControls.startDate.value = formatDateToYYYYMMDD(today);
            }
            if (els.main.apiControls.endDate) {
                els.main.apiControls.endDate.value = formatDateToYYYYMMDD(today);
            }
            if (els.main.apiControls.startTime) {
                els.main.apiControls.startTime.value = '00:00';
            }
            if (els.main.apiControls.endTime) {
                els.main.apiControls.endTime.value = '23:59';
            }

            // Inicia com o dashboard de pausas
            showDashboard('pauses');
        }

        function exportarDadosParaHtml() {
            // Clona a tabela para não modificar a original
            const tabelaOriginal = tabulatorTable.element;
            const tabelaClone = tabelaOriginal.cloneNode(true);
        
            // Remove os filtros do cabeçalho da cópia
            const filtros = tabelaClone.querySelectorAll('.tabulator-header-filter');
            filtros.forEach(filtro => filtro.parentNode.removeChild(filtro));
        
            // Estilos básicos para a exportação
            const estilos = `
                <style>
                    body { font-family: sans-serif; }
                    table { border-collapse: collapse; width: 100%; }
                    th, td { border: 1px solid #dddddd; text-align: left; padding: 8px; }
                    tr:nth-child(even) { background-color: #f2f2f2; }
                    th { background-color: #4CAF50; color: white; }
                </style>
            `;
        
            const nomeArquivo = 'dados_pausa.html';
            const html = `
                <!DOCTYPE html>
                <html lang="pt-BR">
                <head>
                    <meta charset="UTF-8">
                    <title>Exportação de Pausas</title>
                    ${estilos}
                </head>
                <body>
                    <h1>Relatório de Pausas</h1>
                    ${tabelaClone.outerHTML}
                </body>
                </html>
            `;
        
            const link = document.createElement('a');
            link.href = 'data:text/html;charset=utf-8,' + encodeURIComponent(html);
            link.download = nomeArquivo;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- Inicialização da Aplicação ---
        document.addEventListener('DOMContentLoaded', init);
    </script>
        <!-- Menu rápido flutuante minimalista -->
        <div id="quick-menu" class="quick-menu">
            <button id="quick-main-btn" class="quick-main" aria-label="Menu rápido">
                <svg id="quick-main-icon" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>
            </button>
            <div class="quick-items">
                <button id="quick-filter-btn" class="quick-item" aria-label="Abrir filtros">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 4a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v2.586a1 1 0 0 1-.293.707l-6.414 6.414a1 1 0 0 0-.293.707V17l-4 4v-6.586a1 1 0 0 0-.293.707L3.293 7.293A1 1 0 0 1 3 6.586V4z"/></svg>
                    <span class="quick-tooltip">Filtros</span>
                </button>
                <button id="quick-report-btn" class="quick-item" aria-label="Relatório de Pausas">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 5v14M15 5v14"/></svg>
                    <span class="quick-tooltip">Relatório de Pausas</span>
                </button>
                <button id="quick-ai-btn" class="quick-item" aria-label="Análise IA">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="2" y="2" width="20" height="20" rx="6" ry="6" stroke-width="2"/>
                        <text x="12" y="14" text-anchor="middle" font-size="11" font-weight="700" fill="currentColor">IA</text>
                    </svg>
                    <span class="quick-tooltip">Análise IA</span>
                </button>
            </div>
        </div>
        <button id="floating-ai-btn" class="fixed bottom-4 right-4 md:bottom-6 md:right-6 z-50 p-4 rounded-full bg-blue-600 text-white shadow-lg hover:bg-blue-700 transition-all duration-300 ease-in-out transform hover:scale-110">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
        </svg>
    </button>
        <button id="floating-filter-btn" class="fixed bottom-4 right-20 md:bottom-6 md:right-24 z-50 p-4 rounded-full bg-indigo-600 text-white shadow-lg hover:bg-indigo-700 transition-all duration-300 ease-in-out transform hover:scale-110" title="Filtros">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293.707L3.293 7.293A1 1 0 013 6.586V4z" />
        </svg>
    </button>
</body>
</html>